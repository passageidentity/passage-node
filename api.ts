/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Passage Management API
 * Passage's management API to manage your Passage apps and users.
 *
 * OpenAPI spec version: 1
 * Contact: support@passage.id
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.passage.id/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface ApiKey
 */
export interface ApiKey {
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    createdAt: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    keyPrefix: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ApiKey
     */
    role: string;
}
/**
 * 
 * @export
 * @interface ApiKeyResponse
 */
export interface ApiKeyResponse {
    /**
     * 
     * @type {ApiKey}
     * @memberof ApiKeyResponse
     */
    apiKey: ApiKey;
}
/**
 * 
 * @export
 * @interface AppInfo
 */
export interface AppInfo {
    /**
     * 
     * @type {Array<string>}
     * @memberof AppInfo
     */
    additionalAuthOrigins: Array<string>;
    /**
     * The valid URLs where users can be redirected after authentication.
     * @type {Array<string>}
     * @memberof AppInfo
     */
    allowedCallbackUrls: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof AppInfo
     */
    allowedIdentifier: string;
    /**
     * The valid URLs where users can be redirected after logging out.
     * @type {Array<string>}
     * @memberof AppInfo
     */
    allowedLogoutUrls: Array<string>;
    /**
     * A route within your application that redirects to the Authorization URL endpoint.
     * @type {string}
     * @memberof AppInfo
     */
    applicationLoginUri: string;
    /**
     * 
     * @type {string}
     * @memberof AppInfo
     */
    authFallbackMethod: string;
    /**
     * 
     * @type {number}
     * @memberof AppInfo
     */
    authFallbackMethodTtl: number;
    /**
     * 
     * @type {string}
     * @memberof AppInfo
     */
    authOrigin: string;
    /**
     * 
     * @type {Date}
     * @memberof AppInfo
     */
    createdAt: Date;
    /**
     * 
     * @type {string}
     * @memberof AppInfo
     */
    defaultLanguage: string;
    /**
     * 
     * @type {boolean}
     * @memberof AppInfo
     */
    ephemeral: boolean;
    /**
     * 
     * @type {string}
     * @memberof AppInfo
     */
    id: string;
    /**
     * 
     * @type {Layouts}
     * @memberof AppInfo
     */
    layouts: Layouts;
    /**
     * 
     * @type {string}
     * @memberof AppInfo
     */
    loginUrl: string;
    /**
     * 
     * @type {string}
     * @memberof AppInfo
     */
    name: string;
    /**
     * whether or not the app's login page hosted by passage
     * @type {boolean}
     * @memberof AppInfo
     */
    hosted: boolean;
    /**
     * the subdomain of the app's hosted login page
     * @type {string}
     * @memberof AppInfo
     */
    hostedSubdomain: string;
    /**
     * 
     * @type {boolean}
     * @memberof AppInfo
     */
    passageBranding: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AppInfo
     */
    profileManagement: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AppInfo
     */
    publicSignup: boolean;
    /**
     * 
     * @type {string}
     * @memberof AppInfo
     */
    redirectUrl: string;
    /**
     * 
     * @type {number}
     * @memberof AppInfo
     */
    refreshAbsoluteLifetime: number;
    /**
     * 
     * @type {boolean}
     * @memberof AppInfo
     */
    refreshEnabled: boolean;
    /**
     * 
     * @type {number}
     * @memberof AppInfo
     */
    refreshInactivityLifetime: number;
    /**
     * 
     * @type {boolean}
     * @memberof AppInfo
     */
    requireEmailVerification: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AppInfo
     */
    requireIdentifierVerification: boolean;
    /**
     * 
     * @type {string}
     * @memberof AppInfo
     */
    requiredIdentifier: string;
    /**
     * 
     * @type {string}
     * @memberof AppInfo
     */
    role: string;
    /**
     * 
     * @type {string}
     * @memberof AppInfo
     */
    rsaPublicKey: string;
    /**
     * can only be retrieved by an app admin
     * @type {string}
     * @memberof AppInfo
     */
    secret?: string;
    /**
     * 
     * @type {number}
     * @memberof AppInfo
     */
    sessionTimeoutLength: number;
    /**
     * 
     * @type {string}
     * @memberof AppInfo
     */
    type: AppInfo.TypeEnum;
    /**
     * 
     * @type {Array<UserMetadataField>}
     * @memberof AppInfo
     */
    userMetadataSchema: Array<UserMetadataField>;
    /**
     * 
     * @type {Array<Technologies>}
     * @memberof AppInfo
     */
    technologies: Array<Technologies>;
    /**
     * 
     * @type {ElementCustomization}
     * @memberof AppInfo
     */
    elementCustomization: ElementCustomization;
}

/**
 * @export
 * @namespace AppInfo
 */
export namespace AppInfo {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Complete = <any> 'complete',
        Flex = <any> 'flex'
    }
}
/**
 * 
 * @export
 * @interface AppResponse
 */
export interface AppResponse {
    /**
     * 
     * @type {AppInfo}
     * @memberof AppResponse
     */
    app: AppInfo;
}
/**
 * 
 * @export
 * @interface AppStatsResponse
 */
export interface AppStatsResponse {
    /**
     * 
     * @type {number}
     * @memberof AppStatsResponse
     */
    percentMagiclinkUsers: number;
    /**
     * 
     * @type {number}
     * @memberof AppStatsResponse
     */
    percentWebauthnUsers: number;
    /**
     * 
     * @type {number}
     * @memberof AppStatsResponse
     */
    totalUsers: number;
    /**
     * Monthly Active Users
     * @type {number}
     * @memberof AppStatsResponse
     */
    mauCount: number;
}
/**
 * 
 * @export
 * @interface AuthorizerHeaders
 */
export interface AuthorizerHeaders {
    /**
     * 
     * @type {string}
     * @memberof AuthorizerHeaders
     */
    authorization: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizerHeaders
     */
    ip?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizerHeaders
     */
    userAgent?: string;
}
/**
 * 
 * @export
 * @interface AuthorizerResult
 */
export interface AuthorizerResult {
    /**
     * 
     * @type {boolean}
     * @memberof AuthorizerResult
     */
    denyAccess: boolean;
    /**
     * 
     * @type {string}
     * @memberof AuthorizerResult
     */
    reason?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizerResult
     */
    userId?: string;
}
/**
 * 
 * @export
 * @interface AuthorizerTestRequest
 */
export interface AuthorizerTestRequest {
    /**
     * 
     * @type {AuthorizerHeaders}
     * @memberof AuthorizerTestRequest
     */
    headers: AuthorizerHeaders;
}
/**
 * 
 * @export
 * @interface AuthorizerTestResponse
 */
export interface AuthorizerTestResponse {
    /**
     * 
     * @type {TestError}
     * @memberof AuthorizerTestResponse
     */
    error?: TestError;
    /**
     * 
     * @type {Array<string>}
     * @memberof AuthorizerTestResponse
     */
    logs?: Array<string>;
    /**
     * 
     * @type {AuthorizerResult}
     * @memberof AuthorizerTestResponse
     */
    result: AuthorizerResult;
}
/**
 * 
 * @export
 * @interface BootEvent
 */
export interface BootEvent extends EventBase {
    /**
     * 
     * @type {BootEventEvent}
     * @memberof BootEvent
     */
    event: BootEventEvent;
}

/**
 * @export
 * @namespace BootEvent
 */
export namespace BootEvent {
}
/**
 * 
 * @export
 * @interface BootEventEvent
 */
export interface BootEventEvent {
    /**
     * The time it took to boot the isolate, in seconds.
     * @type {number}
     * @memberof BootEventEvent
     */
    bootTime: number;
}
/**
 * 
 * @export
 * @interface BootFailureEvent
 */
export interface BootFailureEvent extends EventBase {
    /**
     * 
     * @type {BootFailureEventEvent}
     * @memberof BootFailureEvent
     */
    event: BootFailureEventEvent;
}

/**
 * @export
 * @namespace BootFailureEvent
 */
export namespace BootFailureEvent {
}
/**
 * 
 * @export
 * @interface BootFailureEventEvent
 */
export interface BootFailureEventEvent {
    /**
     * A human readable message containing information about why the isolate failed to boot.
     * @type {string}
     * @memberof BootFailureEventEvent
     */
    msg: string;
}
/**
 * 
 * @export
 * @interface ClaimAppRequest
 */
export interface ClaimAppRequest {
    /**
     * 
     * @type {string}
     * @memberof ClaimAppRequest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface CreateApiKeyRequest
 */
export interface CreateApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateApiKeyRequest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface CreateApiKeyResponse
 */
export interface CreateApiKeyResponse {
    /**
     * 
     * @type {CreatedApiKey}
     * @memberof CreateApiKeyResponse
     */
    apiKey: CreatedApiKey;
}
/**
 * 
 * @export
 * @interface CreateAppRequest
 */
export interface CreateAppRequest {
    /**
     * The valid URLs where users can be redirected after authentication.
     * @type {Array<string>}
     * @memberof CreateAppRequest
     */
    allowedCallbackUrls?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof CreateAppRequest
     */
    authOrigin?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateAppRequest
     */
    hosted?: boolean;
    /**
     * the subdomain of the app's hosted login page
     * @type {string}
     * @memberof CreateAppRequest
     */
    hostedSubdomain?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAppRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAppRequest
     */
    redirectUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateAppRequest
     */
    organizationId?: string;
    /**
     * 
     * @type {Array<Technologies>}
     * @memberof CreateAppRequest
     */
    technologies?: Array<Technologies>;
    /**
     * 
     * @type {string}
     * @memberof CreateAppRequest
     */
    type?: CreateAppRequest.TypeEnum;
}

/**
 * @export
 * @namespace CreateAppRequest
 */
export namespace CreateAppRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Complete = <any> 'complete',
        Flex = <any> 'flex'
    }
}
/**
 * 
 * @export
 * @interface CreateEmailTemplateRequest
 */
export interface CreateEmailTemplateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof CreateEmailTemplateRequest
     */
    enabled?: boolean;
    /**
     * 
     * @type {EmailTemplateType}
     * @memberof CreateEmailTemplateRequest
     */
    type: EmailTemplateType;
    /**
     * 
     * @type {string}
     * @memberof CreateEmailTemplateRequest
     */
    html: string;
    /**
     * 
     * @type {string}
     * @memberof CreateEmailTemplateRequest
     */
    subject: string;
}
/**
 * 
 * @export
 * @interface CreateFunctionRequest
 */
export interface CreateFunctionRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateFunctionRequest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface CreateFunctionSecretRequest
 */
export interface CreateFunctionSecretRequest {
    /**
     * 
     * @type {FunctionSecretKey}
     * @memberof CreateFunctionSecretRequest
     */
    key: FunctionSecretKey;
    /**
     * 
     * @type {string}
     * @memberof CreateFunctionSecretRequest
     */
    value: string;
}
/**
 * 
 * @export
 * @interface CreateMagicLinkRequest
 */
export interface CreateMagicLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateMagicLinkRequest
     */
    channel: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMagicLinkRequest
     */
    email: string;
    /**
     * language of the email to send (optional)
     * @type {string}
     * @memberof CreateMagicLinkRequest
     */
    language?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMagicLinkRequest
     */
    magicLinkPath: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMagicLinkRequest
     */
    phone: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMagicLinkRequest
     */
    redirectUrl: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateMagicLinkRequest
     */
    send: boolean;
    /**
     * 
     * @type {number}
     * @memberof CreateMagicLinkRequest
     */
    ttl: number;
    /**
     * 
     * @type {string}
     * @memberof CreateMagicLinkRequest
     */
    type?: CreateMagicLinkRequest.TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CreateMagicLinkRequest
     */
    userId: string;
}

/**
 * @export
 * @namespace CreateMagicLinkRequest
 */
export namespace CreateMagicLinkRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Login = <any> 'login',
        VerifyIdentifier = <any> 'verify_identifier'
    }
}
/**
 * 
 * @export
 * @interface CreateUserMetadataField
 */
export interface CreateUserMetadataField {
    /**
     * 
     * @type {string}
     * @memberof CreateUserMetadataField
     */
    friendlyName: string;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserMetadataField
     */
    profile: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CreateUserMetadataField
     */
    registration: boolean;
    /**
     * 
     * @type {UserMetadataFieldType}
     * @memberof CreateUserMetadataField
     */
    type: UserMetadataFieldType;
}
/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    phone: string;
    /**
     * 
     * @type {any}
     * @memberof CreateUserRequest
     */
    userMetadata?: any;
}
/**
 * 
 * @export
 * @interface CreatedApiKey
 */
export interface CreatedApiKey extends ApiKey {
    /**
     * 
     * @type {string}
     * @memberof CreatedApiKey
     */
    plaintextKey: string;
}
/**
 * 
 * @export
 * @interface ElementCustomization
 */
export interface ElementCustomization {
    /**
     * Container background color
     * @type {string}
     * @memberof ElementCustomization
     */
    passageContainerBackgroundColor?: string;
    /**
     * Maximum width of container (px)
     * @type {number}
     * @memberof ElementCustomization
     */
    passageContainerMaxWidth?: number;
    /**
     * Input box background color (hex)
     * @type {string}
     * @memberof ElementCustomization
     */
    passageInputBoxBackgroundColor?: string;
    /**
     * Input box border radius (px)
     * @type {number}
     * @memberof ElementCustomization
     */
    passageInputBoxBorderRadius?: number;
    /**
     * 
     * @type {FontFamily}
     * @memberof ElementCustomization
     */
    passageHeaderFontFamily?: FontFamily;
    /**
     * 
     * @type {FontFamily}
     * @memberof ElementCustomization
     */
    passageBodyFontFamily?: FontFamily;
    /**
     * Header font colour (hex)
     * @type {string}
     * @memberof ElementCustomization
     */
    passageHeaderTextColor?: string;
    /**
     * Body font colour (hex)
     * @type {string}
     * @memberof ElementCustomization
     */
    passageBodyTextColor?: string;
    /**
     * Primary button background colour (hex)
     * @type {string}
     * @memberof ElementCustomization
     */
    passagePrimaryButtonBackgroundColor?: string;
    /**
     * Primary button font colour (hex)
     * @type {string}
     * @memberof ElementCustomization
     */
    passagePrimaryButtonTextColor?: string;
    /**
     * Primary button background on hover (hex)
     * @type {string}
     * @memberof ElementCustomization
     */
    passagePrimaryButtonHoverColor?: string;
    /**
     * Primary button border radius (px)
     * @type {number}
     * @memberof ElementCustomization
     */
    passagePrimaryButtonBorderRadius?: number;
    /**
     * Secondary button background colour (hex)
     * @type {string}
     * @memberof ElementCustomization
     */
    passageSecondaryButtonBackgroundColor?: string;
    /**
     * Secondary button font colour (hex)
     * @type {string}
     * @memberof ElementCustomization
     */
    passageSecondaryButtonTextColor?: string;
    /**
     * Secondary button background on hover (hex)
     * @type {string}
     * @memberof ElementCustomization
     */
    passageSecondaryButtonHoverColor?: string;
    /**
     * Secondary button border radius (px)
     * @type {number}
     * @memberof ElementCustomization
     */
    passageSecondaryButtonBorderRadius?: number;
}
/**
 * 
 * @export
 * @interface EmailProvider
 */
export interface EmailProvider {
    /**
     * 
     * @type {EmailProviderConfig}
     * @memberof EmailProvider
     */
    config?: EmailProviderConfig;
    /**
     * 
     * @type {boolean}
     * @memberof EmailProvider
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EmailProvider
     */
    fromAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailProvider
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface EmailProviderConfig
 */
export interface EmailProviderConfig {
    /**
     * 
     * @type {string}
     * @memberof EmailProviderConfig
     */
    apiKey?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailProviderConfig
     */
    accessKeyId?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailProviderConfig
     */
    accessKeySecret?: string;
    /**
     * 
     * @type {string}
     * @memberof EmailProviderConfig
     */
    region?: string;
}
/**
 * 
 * @export
 * @interface EmailProviderResponse
 */
export interface EmailProviderResponse {
    /**
     * 
     * @type {boolean}
     * @memberof EmailProviderResponse
     */
    enabled: boolean;
    /**
     * 
     * @type {string}
     * @memberof EmailProviderResponse
     */
    fromAddress: string;
    /**
     * 
     * @type {string}
     * @memberof EmailProviderResponse
     */
    type: string;
}
/**
 * 
 * @export
 * @interface EmailTemplate
 */
export interface EmailTemplate {
    /**
     * empty string indicates the template is a default template.
     * @type {string}
     * @memberof EmailTemplate
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof EmailTemplate
     */
    enabled: boolean;
    /**
     * 
     * @type {EmailTemplateType}
     * @memberof EmailTemplate
     */
    type: EmailTemplateType;
    /**
     * 
     * @type {string}
     * @memberof EmailTemplate
     */
    html: string;
    /**
     * 
     * @type {string}
     * @memberof EmailTemplate
     */
    subject: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum EmailTemplateType {
    MagicLink = <any> 'magic_link',
    EmailChange = <any> 'email_change',
    EmailVerify = <any> 'email_verify',
    Otp = <any> 'otp'
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
}
/**
 * 
 * @export
 * @interface EventBase
 */
export interface EventBase {
    /**
     * The ID of the deployment that caused this event to be generated.
     * @type {string}
     * @memberof EventBase
     */
    deploymentId: string;
    /**
     * The type of event.
     * @type {string}
     * @memberof EventBase
     */
    eventType: EventBase.EventTypeEnum;
    /**
     * Timestamp for when this event was created, in RFC3339 format.
     * @type {Date}
     * @memberof EventBase
     */
    timestamp: Date;
    /**
     * If the event was caused by a running isolate, this field contains the opaque ID of the given isolate.
     * @type {string}
     * @memberof EventBase
     */
    isolateId?: string;
    /**
     * The region where the event was generated. Refer to https://deno.com/deploy/docs/regions for possible values.
     * @type {string}
     * @memberof EventBase
     */
    region: string;
}

/**
 * @export
 * @namespace EventBase
 */
export namespace EventBase {
    /**
     * @export
     * @enum {string}
     */
    export enum EventTypeEnum {
        Boot = <any> 'boot',
        BootFailure = <any> 'bootFailure',
        Log = <any> 'log',
        UncaughtException = <any> 'uncaughtException',
        MemoryLimit = <any> 'memoryLimit',
        TimeLimit = <any> 'timeLimit'
    }
}
/**
 * 
 * @export
 * @interface EventInfo
 */
export interface EventInfo {
    /**
     * 
     * @type {string}
     * @memberof EventInfo
     */
    createdAt: string;
    /**
     * 
     * @type {any}
     * @memberof EventInfo
     */
    data: any;
    /**
     * 
     * @type {string}
     * @memberof EventInfo
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof EventInfo
     */
    identifier: string;
    /**
     * 
     * @type {string}
     * @memberof EventInfo
     */
    ipAddr: string;
    /**
     * 
     * @type {string}
     * @memberof EventInfo
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof EventInfo
     */
    userAgent: string;
    /**
     * 
     * @type {string}
     * @memberof EventInfo
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface EventResponse
 */
export interface EventResponse {
    /**
     * 
     * @type {EventInfo}
     * @memberof EventResponse
     */
    event: EventInfo;
}
/**
 * Body font family
 * @export
 * @enum {string}
 */
export enum FontFamily {
    Helvetica = <any> 'Helvetica',
    Arial = <any> 'Arial',
    ArialBlack = <any> 'Arial Black',
    Verdana = <any> 'Verdana',
    Tahoma = <any> 'Tahoma',
    TrebuchetMS = <any> 'Trebuchet MS',
    Impact = <any> 'Impact',
    GillSans = <any> 'Gill Sans',
    TimesNewRoman = <any> 'Times New Roman',
    Georgia = <any> 'Georgia',
    Palatino = <any> 'Palatino',
    Baskerville = <any> 'Baskerville',
    AndalMono = <any> 'Andalé Mono',
    Courier = <any> 'Courier',
    Lucida = <any> 'Lucida',
    Monaco = <any> 'Monaco',
    BradleyHand = <any> 'Bradley Hand',
    BrushScriptMT = <any> 'Brush Script MT',
    Luminari = <any> 'Luminari',
    ComicSansMS = <any> 'Comic Sans MS'
}
/**
 * 
 * @export
 * @interface FunctionResponse
 */
export interface FunctionResponse {
    /**
     * 
     * @type {string}
     * @memberof FunctionResponse
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof FunctionResponse
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FunctionResponse
     */
    code: string;
    /**
     * 
     * @type {Language}
     * @memberof FunctionResponse
     */
    language: Language;
    /**
     * 
     * @type {boolean}
     * @memberof FunctionResponse
     */
    hasDraft: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof FunctionResponse
     */
    secretKeys: Array<string>;
}
/**
 * 
 * @export
 */
export type FunctionSecretKey = string
/**
 * 
 * @export
 * @interface GetFunctionVersionResponse
 */
export interface GetFunctionVersionResponse {
    /**
     * 
     * @type {string}
     * @memberof GetFunctionVersionResponse
     */
    id: string;
    /**
     * 
     * @type {number}
     * @memberof GetFunctionVersionResponse
     */
    version: number;
    /**
     * 
     * @type {Date}
     * @memberof GetFunctionVersionResponse
     */
    createdAt: Date;
    /**
     * 
     * @type {string}
     * @memberof GetFunctionVersionResponse
     */
    code: string;
    /**
     * 
     * @type {Language}
     * @memberof GetFunctionVersionResponse
     */
    language: Language;
}
/**
 * 
 * @export
 * @interface GetTypesResponse
 */
export interface GetTypesResponse {
    /**
     * 
     * @type {string}
     * @memberof GetTypesResponse
     */
    types: string;
}
/**
 * 
 * @export
 * @interface ImportUsersRequest
 */
export interface ImportUsersRequest {
    /**
     * file type: text/csv
     * @type {Blob}
     * @memberof ImportUsersRequest
     */
    csvUserImport: Blob;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<EmailTemplate>}
     * @memberof InlineResponse200
     */
    templates: Array<EmailTemplate>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {EmailTemplate}
     * @memberof InlineResponse2001
     */
    template?: EmailTemplate;
}
/**
 * 
 * @export
 * @interface InlineResponse201
 */
export interface InlineResponse201 {
    /**
     * 
     * @type {EmailTemplate}
     * @memberof InlineResponse201
     */
    template: EmailTemplate;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Language {
    Js = <any> 'js',
    Ts = <any> 'ts'
}
/**
 * 
 * @export
 * @interface LayoutConfig
 */
export interface LayoutConfig {
    /**
     * 
     * @type {number}
     * @memberof LayoutConfig
     */
    h: number;
    /**
     * 
     * @type {string}
     * @memberof LayoutConfig
     */
    id: string;
    /**
     * 
     * @type {number}
     * @memberof LayoutConfig
     */
    w: number;
    /**
     * 
     * @type {number}
     * @memberof LayoutConfig
     */
    x: number;
    /**
     * 
     * @type {number}
     * @memberof LayoutConfig
     */
    y: number;
}
/**
 * 
 * @export
 * @interface Layouts
 */
export interface Layouts {
    /**
     * 
     * @type {Array<LayoutConfig>}
     * @memberof Layouts
     */
    profile: Array<LayoutConfig>;
    /**
     * 
     * @type {Array<LayoutConfig>}
     * @memberof Layouts
     */
    registration: Array<LayoutConfig>;
}
/**
 * 
 * @export
 * @interface LayoutsResponse
 */
export interface LayoutsResponse {
    /**
     * 
     * @type {Layouts}
     * @memberof LayoutsResponse
     */
    layouts: Layouts;
}
/**
 * 
 * @export
 * @interface Link
 */
export interface Link {
    /**
     * 
     * @type {string}
     * @memberof Link
     */
    href: string;
}
/**
 * 
 * @export
 * @interface ListApiKeysResponse
 */
export interface ListApiKeysResponse {
    /**
     * 
     * @type {Array<ApiKey>}
     * @memberof ListApiKeysResponse
     */
    apiKeys: Array<ApiKey>;
}
/**
 * 
 * @export
 * @interface ListDevicesResponse
 */
export interface ListDevicesResponse {
    /**
     * 
     * @type {Array<WebAuthnDevices>}
     * @memberof ListDevicesResponse
     */
    devices: Array<WebAuthnDevices>;
}
/**
 * 
 * @export
 * @interface ListFunctionEventsItem
 */
export interface ListFunctionEventsItem {
    /**
     * The timestamp of the event as Unix milliseconds.
     * @type {number}
     * @memberof ListFunctionEventsItem
     */
    timestamp: number;
    /**
     * 
     * @type {Event}
     * @memberof ListFunctionEventsItem
     */
    data: Event;
}
/**
 * 
 * @export
 * @interface ListFunctionEventsResponse
 */
export interface ListFunctionEventsResponse {
    /**
     * 
     * @type {Array<ListFunctionEventsItem>}
     * @memberof ListFunctionEventsResponse
     */
    functionEvents: Array<ListFunctionEventsItem>;
    /**
     * The timestamp offset of the events in this response, as Unix milliseconds.
     * @type {number}
     * @memberof ListFunctionEventsResponse
     */
    since: number;
    /**
     * The last timestamp of the events in this response, as Unix milliseconds. Use it as the `since` query parameter in the next request to get the next page.
     * @type {number}
     * @memberof ListFunctionEventsResponse
     */
    until: number;
}
/**
 * 
 * @export
 * @interface ListFunctionVersionsItem
 */
export interface ListFunctionVersionsItem {
    /**
     * 
     * @type {string}
     * @memberof ListFunctionVersionsItem
     */
    id: string;
    /**
     * The version number. `0` indicates a draft.
     * @type {number}
     * @memberof ListFunctionVersionsItem
     */
    version: number;
    /**
     * 
     * @type {Date}
     * @memberof ListFunctionVersionsItem
     */
    createdAt: Date;
}
/**
 * 
 * @export
 * @interface ListFunctionVersionsResponse
 */
export interface ListFunctionVersionsResponse {
    /**
     * 
     * @type {Array<ListFunctionVersionsItem>}
     * @memberof ListFunctionVersionsResponse
     */
    functionVersions: Array<ListFunctionVersionsItem>;
}
/**
 * 
 * @export
 * @interface ListFunctionsItem
 */
export interface ListFunctionsItem {
    /**
     * 
     * @type {string}
     * @memberof ListFunctionsItem
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof ListFunctionsItem
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ListFunctionsResponse
 */
export interface ListFunctionsResponse {
    /**
     * 
     * @type {Array<ListFunctionsItem>}
     * @memberof ListFunctionsResponse
     */
    functions: Array<ListFunctionsItem>;
}
/**
 * 
 * @export
 * @interface ListPaginatedEventsResponse
 */
export interface ListPaginatedEventsResponse {
    /**
     * 
     * @type {PaginatedLinks}
     * @memberof ListPaginatedEventsResponse
     */
    links: PaginatedLinks;
    /**
     * time anchor (Unix timestamp) --> all events returned were created before this timestamp
     * @type {number}
     * @memberof ListPaginatedEventsResponse
     */
    createdBefore: number;
    /**
     * 
     * @type {Array<EventInfo>}
     * @memberof ListPaginatedEventsResponse
     */
    events: Array<EventInfo>;
    /**
     * 
     * @type {number}
     * @memberof ListPaginatedEventsResponse
     */
    limit: number;
    /**
     * 
     * @type {number}
     * @memberof ListPaginatedEventsResponse
     */
    page: number;
    /**
     * total number of event for a particular query
     * @type {number}
     * @memberof ListPaginatedEventsResponse
     */
    totalEvents: number;
}
/**
 * 
 * @export
 * @interface ListPaginatedUsersResponse
 */
export interface ListPaginatedUsersResponse {
    /**
     * 
     * @type {PaginatedLinks}
     * @memberof ListPaginatedUsersResponse
     */
    links: PaginatedLinks;
    /**
     * time anchor (Unix timestamp) --> all users returned created before this timestamp
     * @type {number}
     * @memberof ListPaginatedUsersResponse
     */
    createdBefore: number;
    /**
     * 
     * @type {number}
     * @memberof ListPaginatedUsersResponse
     */
    limit: number;
    /**
     * 
     * @type {number}
     * @memberof ListPaginatedUsersResponse
     */
    page: number;
    /**
     * total number of users for a particular query
     * @type {number}
     * @memberof ListPaginatedUsersResponse
     */
    totalUsers: number;
    /**
     * 
     * @type {Array<UserInfo>}
     * @memberof ListPaginatedUsersResponse
     */
    users: Array<UserInfo>;
}
/**
 * 
 * @export
 * @interface LogEvent
 */
export interface LogEvent extends EventBase {
    /**
     * 
     * @type {LogEventEvent}
     * @memberof LogEvent
     */
    event: LogEventEvent;
}

/**
 * @export
 * @namespace LogEvent
 */
export namespace LogEvent {
}
/**
 * 
 * @export
 * @interface LogEventEvent
 */
export interface LogEventEvent {
    /**
     * The message that was logged. The message may contain ANSI escape codes to colorize the message.
     * @type {string}
     * @memberof LogEventEvent
     */
    msg: string;
    /**
     * 
     * @type {string}
     * @memberof LogEventEvent
     */
    level: LogEventEvent.LevelEnum;
}

/**
 * @export
 * @namespace LogEventEvent
 */
export namespace LogEventEvent {
    /**
     * @export
     * @enum {string}
     */
    export enum LevelEnum {
        Debug = <any> 'debug',
        Info = <any> 'info',
        Warning = <any> 'warning',
        Error = <any> 'error'
    }
}
/**
 * 
 * @export
 * @interface MagicLink
 */
export interface MagicLink {
    /**
     * 
     * @type {boolean}
     * @memberof MagicLink
     */
    activated: boolean;
    /**
     * 
     * @type {string}
     * @memberof MagicLink
     */
    appId: string;
    /**
     * 
     * @type {string}
     * @memberof MagicLink
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof MagicLink
     */
    identifier: string;
    /**
     * 
     * @type {string}
     * @memberof MagicLink
     */
    redirectUrl: string;
    /**
     * 
     * @type {string}
     * @memberof MagicLink
     */
    secret: string;
    /**
     * 
     * @type {number}
     * @memberof MagicLink
     */
    ttl: number;
    /**
     * 
     * @type {string}
     * @memberof MagicLink
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof MagicLink
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof MagicLink
     */
    userId: string;
}
/**
 * 
 * @export
 * @interface MagicLinkResponse
 */
export interface MagicLinkResponse {
    /**
     * 
     * @type {MagicLink}
     * @memberof MagicLinkResponse
     */
    magicLink: MagicLink;
}
/**
 * 
 * @export
 * @interface MemoryLimitEvent
 */
export interface MemoryLimitEvent extends EventBase {
    /**
     * 
     * @type {any}
     * @memberof MemoryLimitEvent
     */
    event: any;
}

/**
 * @export
 * @namespace MemoryLimitEvent
 */
export namespace MemoryLimitEvent {
}
/**
 * 
 * @export
 * @interface Model400Error
 */
export interface Model400Error {
    /**
     * 
     * @type {string}
     * @memberof Model400Error
     */
    code: Model400Error.CodeEnum;
    /**
     * 
     * @type {string}
     * @memberof Model400Error
     */
    error: string;
}

/**
 * @export
 * @namespace Model400Error
 */
export namespace Model400Error {
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        InvalidRequest = <any> 'invalid_request',
        CustomProviderRequired = <any> 'custom_provider_required'
    }
}
/**
 * 
 * @export
 * @interface Model401Error
 */
export interface Model401Error {
    /**
     * 
     * @type {string}
     * @memberof Model401Error
     */
    code: Model401Error.CodeEnum;
    /**
     * 
     * @type {string}
     * @memberof Model401Error
     */
    error: string;
}

/**
 * @export
 * @namespace Model401Error
 */
export namespace Model401Error {
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        InvalidAccessToken = <any> 'invalid_access_token'
    }
}
/**
 * 
 * @export
 * @interface Model403Error
 */
export interface Model403Error {
    /**
     * 
     * @type {string}
     * @memberof Model403Error
     */
    code: Model403Error.CodeEnum;
    /**
     * 
     * @type {string}
     * @memberof Model403Error
     */
    error: string;
}

/**
 * @export
 * @namespace Model403Error
 */
export namespace Model403Error {
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        CreateOrganizationBillingPortalSession = <any> 'cannot_create_organization_billing_portal_session',
        DeleteAdmin = <any> 'cannot_delete_admin',
        DeleteOrganizationMember = <any> 'cannot_delete_organization_member',
        SelfUpdateOrganizationMember = <any> 'cannot_self_update_organization_member'
    }
}
/**
 * 
 * @export
 * @interface Model404Error
 */
export interface Model404Error {
    /**
     * 
     * @type {string}
     * @memberof Model404Error
     */
    code: Model404Error.CodeEnum;
    /**
     * 
     * @type {string}
     * @memberof Model404Error
     */
    error: string;
}

/**
 * @export
 * @namespace Model404Error
 */
export namespace Model404Error {
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        AdminNotFound = <any> 'admin_not_found',
        ApiKeyNotFound = <any> 'api_key_not_found',
        AppNotFound = <any> 'app_not_found',
        DeviceNotFound = <any> 'device_not_found',
        EmailProviderNotFound = <any> 'email_provider_not_found',
        EmailTemplateNotFound = <any> 'email_template_not_found',
        EventNotFound = <any> 'event_not_found',
        FunctionNotFound = <any> 'function_not_found',
        FunctionSecretKeyNotFound = <any> 'function_secret_key_not_found',
        FunctionVersionNotFound = <any> 'function_version_not_found',
        MetadataFieldNotFound = <any> 'metadata_field_not_found',
        UserNotFound = <any> 'user_not_found'
    }
}
/**
 * 
 * @export
 * @interface Model409Error
 */
export interface Model409Error {
    /**
     * 
     * @type {string}
     * @memberof Model409Error
     */
    code: Model409Error.CodeEnum;
    /**
     * 
     * @type {string}
     * @memberof Model409Error
     */
    error: string;
}

/**
 * @export
 * @namespace Model409Error
 */
export namespace Model409Error {
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        CannotClaimApp = <any> 'cannot_claim_app',
        UserAlreadyAdmin = <any> 'user_already_admin',
        UserAlreadyOrganizationMember = <any> 'user_already_organization_member'
    }
}
/**
 * 
 * @export
 * @interface Model500Error
 */
export interface Model500Error {
    /**
     * 
     * @type {string}
     * @memberof Model500Error
     */
    code: Model500Error.CodeEnum;
    /**
     * 
     * @type {string}
     * @memberof Model500Error
     */
    error: string;
}

/**
 * @export
 * @namespace Model500Error
 */
export namespace Model500Error {
    /**
     * @export
     * @enum {string}
     */
    export enum CodeEnum {
        InternalServerError = <any> 'internal_server_error'
    }
}
/**
 * 
 * @export
 * @interface PaginatedLinks
 */
export interface PaginatedLinks {
    /**
     * 
     * @type {Link}
     * @memberof PaginatedLinks
     */
    first: Link;
    /**
     * 
     * @type {Link}
     * @memberof PaginatedLinks
     */
    last: Link;
    /**
     * 
     * @type {Link}
     * @memberof PaginatedLinks
     */
    next: Link;
    /**
     * 
     * @type {Link}
     * @memberof PaginatedLinks
     */
    previous: Link;
    /**
     * 
     * @type {Link}
     * @memberof PaginatedLinks
     */
    self: Link;
}
/**
 * 
 * @export
 * @interface SendEmailRequest
 */
export interface SendEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof SendEmailRequest
     */
    htmlTemplate: string;
    /**
     * 
     * @type {string}
     * @memberof SendEmailRequest
     */
    recipientEmail: string;
    /**
     * 
     * @type {string}
     * @memberof SendEmailRequest
     */
    subject: string;
    /**
     * 
     * @type {any}
     * @memberof SendEmailRequest
     */
    variables: any;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Technologies {
    React = <any> 'react',
    Go = <any> 'go',
    Vue = <any> 'vue',
    Angular = <any> 'angular',
    Python = <any> 'python',
    Javascript = <any> 'javascript',
    Ios = <any> 'ios',
    Android = <any> 'android'
}
/**
 * 
 * @export
 * @interface TestError
 */
export interface TestError {
    /**
     * 
     * @type {string}
     * @memberof TestError
     */
    message?: string;
    /**
     * 
     * @type {string}
     * @memberof TestError
     */
    stack?: string;
}
/**
 * 
 * @export
 * @interface TimeLimitEvent
 */
export interface TimeLimitEvent extends EventBase {
    /**
     * 
     * @type {any}
     * @memberof TimeLimitEvent
     */
    event: any;
}

/**
 * @export
 * @namespace TimeLimitEvent
 */
export namespace TimeLimitEvent {
}
/**
 * 
 * @export
 * @interface Trigger
 */
export interface Trigger {
    /**
     * 
     * @type {Array<string>}
     * @memberof Trigger
     */
    enabledFunctions: Array<string>;
}
/**
 * 
 * @export
 * @interface UncaughtExceptionEvent
 */
export interface UncaughtExceptionEvent extends EventBase {
    /**
     * 
     * @type {UncaughtExceptionEventEvent}
     * @memberof UncaughtExceptionEvent
     */
    event: UncaughtExceptionEventEvent;
}

/**
 * @export
 * @namespace UncaughtExceptionEvent
 */
export namespace UncaughtExceptionEvent {
}
/**
 * 
 * @export
 * @interface UncaughtExceptionEventEvent
 */
export interface UncaughtExceptionEventEvent {
    /**
     * The message of the exception.
     * @type {string}
     * @memberof UncaughtExceptionEventEvent
     */
    exception: string;
}
/**
 * 
 * @export
 * @interface UpdateApiKeyRequest
 */
export interface UpdateApiKeyRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateApiKeyRequest
     */
    name: string;
}
/**
 * 
 * @export
 * @interface UpdateAppRequest
 */
export interface UpdateAppRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateAppRequest
     */
    additionalAuthOrigins?: Array<string>;
    /**
     * The valid URLs where users can be redirected after authentication.
     * @type {Array<string>}
     * @memberof UpdateAppRequest
     */
    allowedCallbackUrls?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UpdateAppRequest
     */
    allowedIdentifier?: string;
    /**
     * The valid URLs where users can be redirected after logging out.
     * @type {Array<string>}
     * @memberof UpdateAppRequest
     */
    allowedLogoutUrls?: Array<string>;
    /**
     * A route within your application that redirects to the Authorization URL endpoint.
     * @type {string}
     * @memberof UpdateAppRequest
     */
    applicationLoginUri?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAppRequest
     */
    authFallbackMethod?: UpdateAppRequest.AuthFallbackMethodEnum;
    /**
     * 
     * @type {number}
     * @memberof UpdateAppRequest
     */
    authFallbackMethodTtl?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateAppRequest
     */
    authOrigin?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAppRequest
     */
    defaultLanguage?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAppRequest
     */
    loginUrl?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAppRequest
     */
    name?: string;
    /**
     * the subdomain of the app's hosted login page
     * @type {string}
     * @memberof UpdateAppRequest
     */
    hostedSubdomain?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAppRequest
     */
    passageBranding?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAppRequest
     */
    profileManagement?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAppRequest
     */
    publicSignup?: boolean;
    /**
     * A valid URL where users can be redirected after authentication for Embedded Login.
     * @type {string}
     * @memberof UpdateAppRequest
     */
    redirectUrl?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateAppRequest
     */
    refreshAbsoluteLifetime?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAppRequest
     */
    refreshEnabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateAppRequest
     */
    refreshInactivityLifetime?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateAppRequest
     */
    requireIdentifierVerification?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UpdateAppRequest
     */
    sessionTimeoutLength?: number;
    /**
     * 
     * @type {ElementCustomization}
     * @memberof UpdateAppRequest
     */
    elementCustomization?: ElementCustomization;
}

/**
 * @export
 * @namespace UpdateAppRequest
 */
export namespace UpdateAppRequest {
    /**
     * @export
     * @enum {string}
     */
    export enum AuthFallbackMethodEnum {
        MagicLink = <any> 'magic_link',
        Otp = <any> 'otp',
        None = <any> 'none'
    }
}
/**
 * 
 * @export
 * @interface UpdateEmailTemplateRequest
 */
export interface UpdateEmailTemplateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateEmailTemplateRequest
     */
    enabled?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UpdateEmailTemplateRequest
     */
    html?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateEmailTemplateRequest
     */
    subject?: string;
}
/**
 * 
 * @export
 * @interface UpdateFunctionRequest
 */
export interface UpdateFunctionRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateFunctionRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateFunctionRequest
     */
    code: string;
    /**
     * 
     * @type {Language}
     * @memberof UpdateFunctionRequest
     */
    language: Language;
}
/**
 * 
 * @export
 * @interface UpdateFunctionSecretRequest
 */
export interface UpdateFunctionSecretRequest {
    /**
     * 
     * @type {FunctionSecretKey}
     * @memberof UpdateFunctionSecretRequest
     */
    key?: FunctionSecretKey;
    /**
     * 
     * @type {string}
     * @memberof UpdateFunctionSecretRequest
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserMetadataField
 */
export interface UpdateUserMetadataField {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserMetadataField
     */
    friendlyName?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserMetadataField
     */
    profile?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserMetadataField
     */
    registration?: boolean;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    phone?: string;
    /**
     * 
     * @type {any}
     * @memberof UpdateUserRequest
     */
    userMetadata?: any;
}
/**
 * 
 * @export
 * @interface UserCSVImportError
 */
export interface UserCSVImportError {
    /**
     * 
     * @type {Array<string>}
     * @memberof UserCSVImportError
     */
    errors: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof UserCSVImportError
     */
    identifier: string;
}
/**
 * 
 * @export
 * @interface UserCSVImportResponse
 */
export interface UserCSVImportResponse {
    /**
     * 
     * @type {Array<UserCSVImportError>}
     * @memberof UserCSVImportResponse
     */
    errors: Array<UserCSVImportError>;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof UserCSVImportResponse
     */
    existing: Array<{ [key: string]: string; }>;
    /**
     * 
     * @type {Array<{ [key: string]: string; }>}
     * @memberof UserCSVImportResponse
     */
    imported: Array<{ [key: string]: string; }>;
    /**
     * 
     * @type {number}
     * @memberof UserCSVImportResponse
     */
    numUsersErrored: number;
    /**
     * 
     * @type {number}
     * @memberof UserCSVImportResponse
     */
    numUsersExisting: number;
    /**
     * 
     * @type {number}
     * @memberof UserCSVImportResponse
     */
    numUsersImported: number;
    /**
     * 
     * @type {number}
     * @memberof UserCSVImportResponse
     */
    numUsersReceived: number;
}
/**
 * 
 * @export
 * @interface UserEventInfo
 */
export interface UserEventInfo {
    /**
     * 
     * @type {Date}
     * @memberof UserEventInfo
     */
    createdAt: Date;
    /**
     * 
     * @type {string}
     * @memberof UserEventInfo
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof UserEventInfo
     */
    ipAddr: string;
    /**
     * 
     * @type {string}
     * @memberof UserEventInfo
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof UserEventInfo
     */
    userAgent: string;
}
/**
 * 
 * @export
 * @interface UserInfo
 */
export interface UserInfo {
    /**
     * 
     * @type {Date}
     * @memberof UserInfo
     */
    createdAt: Date;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    email: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfo
     */
    emailVerified: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    id: string;
    /**
     * 
     * @type {Date}
     * @memberof UserInfo
     */
    lastLoginAt: Date;
    /**
     * 
     * @type {number}
     * @memberof UserInfo
     */
    loginCount: number;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    phone: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfo
     */
    phoneVerified: boolean;
    /**
     * 
     * @type {Array<UserEventInfo>}
     * @memberof UserInfo
     */
    recentEvents: Array<UserEventInfo>;
    /**
     * 
     * @type {string}
     * @memberof UserInfo
     */
    status: string;
    /**
     * 
     * @type {Date}
     * @memberof UserInfo
     */
    updatedAt: Date;
    /**
     * 
     * @type {any}
     * @memberof UserInfo
     */
    userMetadata: any;
    /**
     * 
     * @type {boolean}
     * @memberof UserInfo
     */
    webauthn: boolean;
    /**
     * 
     * @type {Array<WebAuthnDevices>}
     * @memberof UserInfo
     */
    webauthnDevices: Array<WebAuthnDevices>;
}
/**
 * 
 * @export
 * @interface UserMetadataField
 */
export interface UserMetadataField {
    /**
     * 
     * @type {string}
     * @memberof UserMetadataField
     */
    fieldName: string;
    /**
     * 
     * @type {string}
     * @memberof UserMetadataField
     */
    friendlyName: string;
    /**
     * 
     * @type {string}
     * @memberof UserMetadataField
     */
    id: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserMetadataField
     */
    profile: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserMetadataField
     */
    registration: boolean;
    /**
     * 
     * @type {UserMetadataFieldType}
     * @memberof UserMetadataField
     */
    type: UserMetadataFieldType;
}
/**
 * 
 * @export
 * @interface UserMetadataFieldResponse
 */
export interface UserMetadataFieldResponse {
    /**
     * 
     * @type {UserMetadataField}
     * @memberof UserMetadataFieldResponse
     */
    userMetadataField: UserMetadataField;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum UserMetadataFieldType {
    String = <any> 'string',
    Boolean = <any> 'boolean',
    Integer = <any> 'integer',
    Date = <any> 'date',
    Phone = <any> 'phone',
    Email = <any> 'email'
}
/**
 * 
 * @export
 * @interface UserMetadataSchemaResponse
 */
export interface UserMetadataSchemaResponse {
    /**
     * 
     * @type {Array<UserMetadataField>}
     * @memberof UserMetadataSchemaResponse
     */
    userMetadataSchema: Array<UserMetadataField>;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {UserInfo}
     * @memberof UserResponse
     */
    user: UserInfo;
}
/**
 * 
 * @export
 * @interface WebAuthnDevices
 */
export interface WebAuthnDevices {
    /**
     * The first time this webAuthn device was used to authenticate the user
     * @type {Date}
     * @memberof WebAuthnDevices
     */
    createdAt: Date;
    /**
     * The CredID for this webAuthn device
     * @type {string}
     * @memberof WebAuthnDevices
     */
    credId: string;
    /**
     * The friendly name for the webAuthn device used to authenticate
     * @type {string}
     * @memberof WebAuthnDevices
     */
    friendlyName: string;
    /**
     * The ID of the webAuthn device used for authentication
     * @type {string}
     * @memberof WebAuthnDevices
     */
    id: string;
    /**
     * The last time this webAuthn device was used to authenticate the user
     * @type {Date}
     * @memberof WebAuthnDevices
     */
    lastLoginAt: Date;
    /**
     * The last time this webAuthn device was updated
     * @type {Date}
     * @memberof WebAuthnDevices
     */
    updatedAt: Date;
    /**
     * How many times this webAuthn device has been used to authenticate the user
     * @type {number}
     * @memberof WebAuthnDevices
     */
    usageCount: number;
}
/**
 * ApiKeysApi - fetch parameter creator
 * @export
 */
export const ApiKeysApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new API key.
         * @summary Create API Key
         * @param {CreateApiKeyRequest} body name
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApikey(body: CreateApiKeyRequest, appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createApikey.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling createApikey.');
            }
            const localVarPath = `/apps/{app_id}/api-keys`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateApiKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an API key.
         * @summary Delete API Key
         * @param {string} appId App ID
         * @param {string} apiKeyId API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApikey(appId: string, apiKeyId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling deleteApikey.');
            }
            // verify required parameter 'apiKeyId' is not null or undefined
            if (apiKeyId === null || apiKeyId === undefined) {
                throw new RequiredError('apiKeyId','Required parameter apiKeyId was null or undefined when calling deleteApikey.');
            }
            const localVarPath = `/apps/{app_id}/api-keys/{api_key_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"api_key_id"}}`, encodeURIComponent(String(apiKeyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about an API key.
         * @summary Get API Key
         * @param {string} appId App ID
         * @param {string} apiKeyId API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApikey(appId: string, apiKeyId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getApikey.');
            }
            // verify required parameter 'apiKeyId' is not null or undefined
            if (apiKeyId === null || apiKeyId === undefined) {
                throw new RequiredError('apiKeyId','Required parameter apiKeyId was null or undefined when calling getApikey.');
            }
            const localVarPath = `/apps/{app_id}/api-keys/{api_key_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"api_key_id"}}`, encodeURIComponent(String(apiKeyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List API keys for an application.
         * @summary List API Keys
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApikeys(appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling listApikeys.');
            }
            const localVarPath = `/apps/{app_id}/api-keys`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an API key.
         * @summary Update API Key
         * @param {UpdateApiKeyRequest} body name
         * @param {string} appId App ID
         * @param {string} apiKeyId API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApikey(body: UpdateApiKeyRequest, appId: string, apiKeyId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateApikey.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling updateApikey.');
            }
            // verify required parameter 'apiKeyId' is not null or undefined
            if (apiKeyId === null || apiKeyId === undefined) {
                throw new RequiredError('apiKeyId','Required parameter apiKeyId was null or undefined when calling updateApikey.');
            }
            const localVarPath = `/apps/{app_id}/api-keys/{api_key_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"api_key_id"}}`, encodeURIComponent(String(apiKeyId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateApiKeyRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiKeysApi - functional programming interface
 * @export
 */
export const ApiKeysApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create a new API key.
         * @summary Create API Key
         * @param {CreateApiKeyRequest} body name
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApikey(body: CreateApiKeyRequest, appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CreateApiKeyResponse> {
            const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).createApikey(body, appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an API key.
         * @summary Delete API Key
         * @param {string} appId App ID
         * @param {string} apiKeyId API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApikey(appId: string, apiKeyId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).deleteApikey(appId, apiKeyId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information about an API key.
         * @summary Get API Key
         * @param {string} appId App ID
         * @param {string} apiKeyId API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApikey(appId: string, apiKeyId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiKeyResponse> {
            const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).getApikey(appId, apiKeyId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List API keys for an application.
         * @summary List API Keys
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApikeys(appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListApiKeysResponse> {
            const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).listApikeys(appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update an API key.
         * @summary Update API Key
         * @param {UpdateApiKeyRequest} body name
         * @param {string} appId App ID
         * @param {string} apiKeyId API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApikey(body: UpdateApiKeyRequest, appId: string, apiKeyId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ApiKeyResponse> {
            const localVarFetchArgs = ApiKeysApiFetchParamCreator(configuration).updateApikey(body, appId, apiKeyId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ApiKeysApi - factory interface
 * @export
 */
export const ApiKeysApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a new API key.
         * @summary Create API Key
         * @param {CreateApiKeyRequest} body name
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApikey(body: CreateApiKeyRequest, appId: string, options?: any) {
            return ApiKeysApiFp(configuration).createApikey(body, appId, options)(fetch, basePath);
        },
        /**
         * Delete an API key.
         * @summary Delete API Key
         * @param {string} appId App ID
         * @param {string} apiKeyId API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApikey(appId: string, apiKeyId: string, options?: any) {
            return ApiKeysApiFp(configuration).deleteApikey(appId, apiKeyId, options)(fetch, basePath);
        },
        /**
         * Get information about an API key.
         * @summary Get API Key
         * @param {string} appId App ID
         * @param {string} apiKeyId API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApikey(appId: string, apiKeyId: string, options?: any) {
            return ApiKeysApiFp(configuration).getApikey(appId, apiKeyId, options)(fetch, basePath);
        },
        /**
         * List API keys for an application.
         * @summary List API Keys
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApikeys(appId: string, options?: any) {
            return ApiKeysApiFp(configuration).listApikeys(appId, options)(fetch, basePath);
        },
        /**
         * Update an API key.
         * @summary Update API Key
         * @param {UpdateApiKeyRequest} body name
         * @param {string} appId App ID
         * @param {string} apiKeyId API key ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApikey(body: UpdateApiKeyRequest, appId: string, apiKeyId: string, options?: any) {
            return ApiKeysApiFp(configuration).updateApikey(body, appId, apiKeyId, options)(fetch, basePath);
        },
    };
};

/**
 * ApiKeysApi - object-oriented interface
 * @export
 * @class ApiKeysApi
 * @extends {BaseAPI}
 */
export class ApiKeysApi extends BaseAPI {
    /**
     * Create a new API key.
     * @summary Create API Key
     * @param {CreateApiKeyRequest} body name
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public createApikey(body: CreateApiKeyRequest, appId: string, options?: any) {
        return ApiKeysApiFp(this.configuration).createApikey(body, appId, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an API key.
     * @summary Delete API Key
     * @param {string} appId App ID
     * @param {string} apiKeyId API key ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public deleteApikey(appId: string, apiKeyId: string, options?: any) {
        return ApiKeysApiFp(this.configuration).deleteApikey(appId, apiKeyId, options)(this.fetch, this.basePath);
    }

    /**
     * Get information about an API key.
     * @summary Get API Key
     * @param {string} appId App ID
     * @param {string} apiKeyId API key ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public getApikey(appId: string, apiKeyId: string, options?: any) {
        return ApiKeysApiFp(this.configuration).getApikey(appId, apiKeyId, options)(this.fetch, this.basePath);
    }

    /**
     * List API keys for an application.
     * @summary List API Keys
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public listApikeys(appId: string, options?: any) {
        return ApiKeysApiFp(this.configuration).listApikeys(appId, options)(this.fetch, this.basePath);
    }

    /**
     * Update an API key.
     * @summary Update API Key
     * @param {UpdateApiKeyRequest} body name
     * @param {string} appId App ID
     * @param {string} apiKeyId API key ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiKeysApi
     */
    public updateApikey(body: UpdateApiKeyRequest, appId: string, apiKeyId: string, options?: any) {
        return ApiKeysApiFp(this.configuration).updateApikey(body, appId, apiKeyId, options)(this.fetch, this.basePath);
    }

}
/**
 * AppMetadataSchemaApi - fetch parameter creator
 * @export
 */
export const AppMetadataSchemaApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * For an authorized user add user metadata schema for an app
         * @summary Add user metadata schema for an App
         * @param {Array<CreateUserMetadataField>} body metadata field settings
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAppMetadataSchema(body: Array<CreateUserMetadataField>, appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addAppMetadataSchema.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling addAppMetadataSchema.');
            }
            const localVarPath = `/apps/{app_id}/user-metadata`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Array&lt;CreateUserMetadataField&gt;" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For an authorized user delete a particular metadata field from the user metadata schema
         * @summary Delete a particular metadata field from the user metadata schema
         * @param {string} appId App ID
         * @param {string} metadataFieldId metadata Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetadataField(appId: string, metadataFieldId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling deleteMetadataField.');
            }
            // verify required parameter 'metadataFieldId' is not null or undefined
            if (metadataFieldId === null || metadataFieldId === undefined) {
                throw new RequiredError('metadataFieldId','Required parameter metadataFieldId was null or undefined when calling deleteMetadataField.');
            }
            const localVarPath = `/apps/{app_id}/user-metadata/{metadata_field_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"metadata_field_id"}}`, encodeURIComponent(String(metadataFieldId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For an authorized user get user metadata schema for an app
         * @summary Get user metadata schema for an App
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppMetadataSchema(appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getAppMetadataSchema.');
            }
            const localVarPath = `/apps/{app_id}/user-metadata`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For an authorized user get a particular metadata field from the user metadata schema
         * @summary Get a particular metadata field from the user metadata schema
         * @param {string} appId App ID
         * @param {string} metadataFieldId metadata Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataField(appId: string, metadataFieldId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getMetadataField.');
            }
            // verify required parameter 'metadataFieldId' is not null or undefined
            if (metadataFieldId === null || metadataFieldId === undefined) {
                throw new RequiredError('metadataFieldId','Required parameter metadataFieldId was null or undefined when calling getMetadataField.');
            }
            const localVarPath = `/apps/{app_id}/user-metadata/{metadata_field_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"metadata_field_id"}}`, encodeURIComponent(String(metadataFieldId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update layouts for an app's registration and profile form
         * @summary Update app layouts
         * @param {Layouts} body 
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppLayouts(body: Layouts, appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateAppLayouts.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling updateAppLayouts.');
            }
            const localVarPath = `/apps/{app_id}/layouts`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Layouts" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For an authorized user update a particular metadata field from the user metadata schema
         * @summary Update a particular metadata field from the user metadata schema
         * @param {UpdateUserMetadataField} body metadata field settings
         * @param {string} appId App ID
         * @param {string} metadataFieldId metadata Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetadataField(body: UpdateUserMetadataField, appId: string, metadataFieldId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateMetadataField.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling updateMetadataField.');
            }
            // verify required parameter 'metadataFieldId' is not null or undefined
            if (metadataFieldId === null || metadataFieldId === undefined) {
                throw new RequiredError('metadataFieldId','Required parameter metadataFieldId was null or undefined when calling updateMetadataField.');
            }
            const localVarPath = `/apps/{app_id}/user-metadata/{metadata_field_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"metadata_field_id"}}`, encodeURIComponent(String(metadataFieldId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUserMetadataField" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppMetadataSchemaApi - functional programming interface
 * @export
 */
export const AppMetadataSchemaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * For an authorized user add user metadata schema for an app
         * @summary Add user metadata schema for an App
         * @param {Array<CreateUserMetadataField>} body metadata field settings
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAppMetadataSchema(body: Array<CreateUserMetadataField>, appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserMetadataSchemaResponse> {
            const localVarFetchArgs = AppMetadataSchemaApiFetchParamCreator(configuration).addAppMetadataSchema(body, appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * For an authorized user delete a particular metadata field from the user metadata schema
         * @summary Delete a particular metadata field from the user metadata schema
         * @param {string} appId App ID
         * @param {string} metadataFieldId metadata Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetadataField(appId: string, metadataFieldId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AppMetadataSchemaApiFetchParamCreator(configuration).deleteMetadataField(appId, metadataFieldId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * For an authorized user get user metadata schema for an app
         * @summary Get user metadata schema for an App
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppMetadataSchema(appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserMetadataSchemaResponse> {
            const localVarFetchArgs = AppMetadataSchemaApiFetchParamCreator(configuration).getAppMetadataSchema(appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * For an authorized user get a particular metadata field from the user metadata schema
         * @summary Get a particular metadata field from the user metadata schema
         * @param {string} appId App ID
         * @param {string} metadataFieldId metadata Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataField(appId: string, metadataFieldId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserMetadataFieldResponse> {
            const localVarFetchArgs = AppMetadataSchemaApiFetchParamCreator(configuration).getMetadataField(appId, metadataFieldId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update layouts for an app's registration and profile form
         * @summary Update app layouts
         * @param {Layouts} body 
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppLayouts(body: Layouts, appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<LayoutsResponse> {
            const localVarFetchArgs = AppMetadataSchemaApiFetchParamCreator(configuration).updateAppLayouts(body, appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * For an authorized user update a particular metadata field from the user metadata schema
         * @summary Update a particular metadata field from the user metadata schema
         * @param {UpdateUserMetadataField} body metadata field settings
         * @param {string} appId App ID
         * @param {string} metadataFieldId metadata Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetadataField(body: UpdateUserMetadataField, appId: string, metadataFieldId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserMetadataFieldResponse> {
            const localVarFetchArgs = AppMetadataSchemaApiFetchParamCreator(configuration).updateMetadataField(body, appId, metadataFieldId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AppMetadataSchemaApi - factory interface
 * @export
 */
export const AppMetadataSchemaApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * For an authorized user add user metadata schema for an app
         * @summary Add user metadata schema for an App
         * @param {Array<CreateUserMetadataField>} body metadata field settings
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAppMetadataSchema(body: Array<CreateUserMetadataField>, appId: string, options?: any) {
            return AppMetadataSchemaApiFp(configuration).addAppMetadataSchema(body, appId, options)(fetch, basePath);
        },
        /**
         * For an authorized user delete a particular metadata field from the user metadata schema
         * @summary Delete a particular metadata field from the user metadata schema
         * @param {string} appId App ID
         * @param {string} metadataFieldId metadata Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMetadataField(appId: string, metadataFieldId: string, options?: any) {
            return AppMetadataSchemaApiFp(configuration).deleteMetadataField(appId, metadataFieldId, options)(fetch, basePath);
        },
        /**
         * For an authorized user get user metadata schema for an app
         * @summary Get user metadata schema for an App
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppMetadataSchema(appId: string, options?: any) {
            return AppMetadataSchemaApiFp(configuration).getAppMetadataSchema(appId, options)(fetch, basePath);
        },
        /**
         * For an authorized user get a particular metadata field from the user metadata schema
         * @summary Get a particular metadata field from the user metadata schema
         * @param {string} appId App ID
         * @param {string} metadataFieldId metadata Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataField(appId: string, metadataFieldId: string, options?: any) {
            return AppMetadataSchemaApiFp(configuration).getMetadataField(appId, metadataFieldId, options)(fetch, basePath);
        },
        /**
         * Update layouts for an app's registration and profile form
         * @summary Update app layouts
         * @param {Layouts} body 
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAppLayouts(body: Layouts, appId: string, options?: any) {
            return AppMetadataSchemaApiFp(configuration).updateAppLayouts(body, appId, options)(fetch, basePath);
        },
        /**
         * For an authorized user update a particular metadata field from the user metadata schema
         * @summary Update a particular metadata field from the user metadata schema
         * @param {UpdateUserMetadataField} body metadata field settings
         * @param {string} appId App ID
         * @param {string} metadataFieldId metadata Field ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMetadataField(body: UpdateUserMetadataField, appId: string, metadataFieldId: string, options?: any) {
            return AppMetadataSchemaApiFp(configuration).updateMetadataField(body, appId, metadataFieldId, options)(fetch, basePath);
        },
    };
};

/**
 * AppMetadataSchemaApi - object-oriented interface
 * @export
 * @class AppMetadataSchemaApi
 * @extends {BaseAPI}
 */
export class AppMetadataSchemaApi extends BaseAPI {
    /**
     * For an authorized user add user metadata schema for an app
     * @summary Add user metadata schema for an App
     * @param {Array<CreateUserMetadataField>} body metadata field settings
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppMetadataSchemaApi
     */
    public addAppMetadataSchema(body: Array<CreateUserMetadataField>, appId: string, options?: any) {
        return AppMetadataSchemaApiFp(this.configuration).addAppMetadataSchema(body, appId, options)(this.fetch, this.basePath);
    }

    /**
     * For an authorized user delete a particular metadata field from the user metadata schema
     * @summary Delete a particular metadata field from the user metadata schema
     * @param {string} appId App ID
     * @param {string} metadataFieldId metadata Field ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppMetadataSchemaApi
     */
    public deleteMetadataField(appId: string, metadataFieldId: string, options?: any) {
        return AppMetadataSchemaApiFp(this.configuration).deleteMetadataField(appId, metadataFieldId, options)(this.fetch, this.basePath);
    }

    /**
     * For an authorized user get user metadata schema for an app
     * @summary Get user metadata schema for an App
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppMetadataSchemaApi
     */
    public getAppMetadataSchema(appId: string, options?: any) {
        return AppMetadataSchemaApiFp(this.configuration).getAppMetadataSchema(appId, options)(this.fetch, this.basePath);
    }

    /**
     * For an authorized user get a particular metadata field from the user metadata schema
     * @summary Get a particular metadata field from the user metadata schema
     * @param {string} appId App ID
     * @param {string} metadataFieldId metadata Field ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppMetadataSchemaApi
     */
    public getMetadataField(appId: string, metadataFieldId: string, options?: any) {
        return AppMetadataSchemaApiFp(this.configuration).getMetadataField(appId, metadataFieldId, options)(this.fetch, this.basePath);
    }

    /**
     * Update layouts for an app's registration and profile form
     * @summary Update app layouts
     * @param {Layouts} body 
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppMetadataSchemaApi
     */
    public updateAppLayouts(body: Layouts, appId: string, options?: any) {
        return AppMetadataSchemaApiFp(this.configuration).updateAppLayouts(body, appId, options)(this.fetch, this.basePath);
    }

    /**
     * For an authorized user update a particular metadata field from the user metadata schema
     * @summary Update a particular metadata field from the user metadata schema
     * @param {UpdateUserMetadataField} body metadata field settings
     * @param {string} appId App ID
     * @param {string} metadataFieldId metadata Field ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppMetadataSchemaApi
     */
    public updateMetadataField(body: UpdateUserMetadataField, appId: string, metadataFieldId: string, options?: any) {
        return AppMetadataSchemaApiFp(this.configuration).updateMetadataField(body, appId, metadataFieldId, options)(this.fetch, this.basePath);
    }

}
/**
 * AppsApi - fetch parameter creator
 * @export
 */
export const AppsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assign an app that is currently in test mode to the current authorized user. Test mode apps are created when an App ID is not specified in the Passage custom element.
         * @summary Claim Test App
         * @param {ClaimAppRequest} body name
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimApp(body: ClaimAppRequest, appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling claimApp.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling claimApp.');
            }
            const localVarPath = `/apps/{app_id}/claim`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ClaimAppRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new application. If not authenticated, the app is created in test mode and not assigned to a specific user.
         * @summary Create App
         * @param {CreateAppRequest} body app settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApp(body: CreateAppRequest, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createApp.');
            }
            const localVarPath = `/apps`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateAppRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an application.
         * @summary Delete App
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApp(appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling deleteApp.');
            }
            const localVarPath = `/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get app information.
         * @summary Get App
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApp(appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getApp.');
            }
            const localVarPath = `/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get some basic stats about an app, including the total user count and the percentages of users that are using WebAuthn to login.
         * @summary Get App Stats
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppStats(appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getAppStats.');
            }
            const localVarPath = `/apps/{app_id}/stats`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the settings or authentication configuration for an application.
         * @summary Update App
         * @param {UpdateAppRequest} body app settings
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApp(body: UpdateAppRequest, appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateApp.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling updateApp.');
            }
            const localVarPath = `/apps/{app_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateAppRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AppsApi - functional programming interface
 * @export
 */
export const AppsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Assign an app that is currently in test mode to the current authorized user. Test mode apps are created when an App ID is not specified in the Passage custom element.
         * @summary Claim Test App
         * @param {ClaimAppRequest} body name
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimApp(body: ClaimAppRequest, appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AppResponse> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).claimApp(body, appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a new application. If not authenticated, the app is created in test mode and not assigned to a specific user.
         * @summary Create App
         * @param {CreateAppRequest} body app settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApp(body: CreateAppRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AppResponse> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).createApp(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an application.
         * @summary Delete App
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApp(appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).deleteApp(appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get app information.
         * @summary Get App
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApp(appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AppResponse> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).getApp(appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get some basic stats about an app, including the total user count and the percentages of users that are using WebAuthn to login.
         * @summary Get App Stats
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppStats(appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AppStatsResponse> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).getAppStats(appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update the settings or authentication configuration for an application.
         * @summary Update App
         * @param {UpdateAppRequest} body app settings
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApp(body: UpdateAppRequest, appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AppResponse> {
            const localVarFetchArgs = AppsApiFetchParamCreator(configuration).updateApp(body, appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AppsApi - factory interface
 * @export
 */
export const AppsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Assign an app that is currently in test mode to the current authorized user. Test mode apps are created when an App ID is not specified in the Passage custom element.
         * @summary Claim Test App
         * @param {ClaimAppRequest} body name
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimApp(body: ClaimAppRequest, appId: string, options?: any) {
            return AppsApiFp(configuration).claimApp(body, appId, options)(fetch, basePath);
        },
        /**
         * Create a new application. If not authenticated, the app is created in test mode and not assigned to a specific user.
         * @summary Create App
         * @param {CreateAppRequest} body app settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApp(body: CreateAppRequest, options?: any) {
            return AppsApiFp(configuration).createApp(body, options)(fetch, basePath);
        },
        /**
         * Delete an application.
         * @summary Delete App
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteApp(appId: string, options?: any) {
            return AppsApiFp(configuration).deleteApp(appId, options)(fetch, basePath);
        },
        /**
         * Get app information.
         * @summary Get App
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApp(appId: string, options?: any) {
            return AppsApiFp(configuration).getApp(appId, options)(fetch, basePath);
        },
        /**
         * Get some basic stats about an app, including the total user count and the percentages of users that are using WebAuthn to login.
         * @summary Get App Stats
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAppStats(appId: string, options?: any) {
            return AppsApiFp(configuration).getAppStats(appId, options)(fetch, basePath);
        },
        /**
         * Update the settings or authentication configuration for an application.
         * @summary Update App
         * @param {UpdateAppRequest} body app settings
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateApp(body: UpdateAppRequest, appId: string, options?: any) {
            return AppsApiFp(configuration).updateApp(body, appId, options)(fetch, basePath);
        },
    };
};

/**
 * AppsApi - object-oriented interface
 * @export
 * @class AppsApi
 * @extends {BaseAPI}
 */
export class AppsApi extends BaseAPI {
    /**
     * Assign an app that is currently in test mode to the current authorized user. Test mode apps are created when an App ID is not specified in the Passage custom element.
     * @summary Claim Test App
     * @param {ClaimAppRequest} body name
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public claimApp(body: ClaimAppRequest, appId: string, options?: any) {
        return AppsApiFp(this.configuration).claimApp(body, appId, options)(this.fetch, this.basePath);
    }

    /**
     * Create a new application. If not authenticated, the app is created in test mode and not assigned to a specific user.
     * @summary Create App
     * @param {CreateAppRequest} body app settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public createApp(body: CreateAppRequest, options?: any) {
        return AppsApiFp(this.configuration).createApp(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an application.
     * @summary Delete App
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public deleteApp(appId: string, options?: any) {
        return AppsApiFp(this.configuration).deleteApp(appId, options)(this.fetch, this.basePath);
    }

    /**
     * Get app information.
     * @summary Get App
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public getApp(appId: string, options?: any) {
        return AppsApiFp(this.configuration).getApp(appId, options)(this.fetch, this.basePath);
    }

    /**
     * Get some basic stats about an app, including the total user count and the percentages of users that are using WebAuthn to login.
     * @summary Get App Stats
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public getAppStats(appId: string, options?: any) {
        return AppsApiFp(this.configuration).getAppStats(appId, options)(this.fetch, this.basePath);
    }

    /**
     * Update the settings or authentication configuration for an application.
     * @summary Update App
     * @param {UpdateAppRequest} body app settings
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AppsApi
     */
    public updateApp(body: UpdateAppRequest, appId: string, options?: any) {
        return AppsApiFp(this.configuration).updateApp(body, appId, options)(this.fetch, this.basePath);
    }

}
/**
 * EmailProvidersApi - fetch parameter creator
 * @export
 */
export const EmailProvidersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Configure your Email Provider
         * @summary Configure Email Provider
         * @param {EmailProvider} body email-provider configuration
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailProviderHandler(body: EmailProvider, appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createEmailProviderHandler.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling createEmailProviderHandler.');
            }
            const localVarPath = `/apps/{app_id}/email-provider`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailProvider" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve your Email Provider
         * @summary Get Email Provider
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailProviderHandler(appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getEmailProviderHandler.');
            }
            const localVarPath = `/apps/{app_id}/email-provider`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update your Email Provider
         * @summary Update Email Provider
         * @param {EmailProvider} body email-provider configuration
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailProviderHandler(body: EmailProvider, appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateEmailProviderHandler.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling updateEmailProviderHandler.');
            }
            const localVarPath = `/apps/{app_id}/email-provider`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EmailProvider" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailProvidersApi - functional programming interface
 * @export
 */
export const EmailProvidersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Configure your Email Provider
         * @summary Configure Email Provider
         * @param {EmailProvider} body email-provider configuration
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailProviderHandler(body: EmailProvider, appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailProviderResponse> {
            const localVarFetchArgs = EmailProvidersApiFetchParamCreator(configuration).createEmailProviderHandler(body, appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieve your Email Provider
         * @summary Get Email Provider
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailProviderHandler(appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailProviderResponse> {
            const localVarFetchArgs = EmailProvidersApiFetchParamCreator(configuration).getEmailProviderHandler(appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update your Email Provider
         * @summary Update Email Provider
         * @param {EmailProvider} body email-provider configuration
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailProviderHandler(body: EmailProvider, appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EmailProviderResponse> {
            const localVarFetchArgs = EmailProvidersApiFetchParamCreator(configuration).updateEmailProviderHandler(body, appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmailProvidersApi - factory interface
 * @export
 */
export const EmailProvidersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Configure your Email Provider
         * @summary Configure Email Provider
         * @param {EmailProvider} body email-provider configuration
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailProviderHandler(body: EmailProvider, appId: string, options?: any) {
            return EmailProvidersApiFp(configuration).createEmailProviderHandler(body, appId, options)(fetch, basePath);
        },
        /**
         * Retrieve your Email Provider
         * @summary Get Email Provider
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailProviderHandler(appId: string, options?: any) {
            return EmailProvidersApiFp(configuration).getEmailProviderHandler(appId, options)(fetch, basePath);
        },
        /**
         * Update your Email Provider
         * @summary Update Email Provider
         * @param {EmailProvider} body email-provider configuration
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailProviderHandler(body: EmailProvider, appId: string, options?: any) {
            return EmailProvidersApiFp(configuration).updateEmailProviderHandler(body, appId, options)(fetch, basePath);
        },
    };
};

/**
 * EmailProvidersApi - object-oriented interface
 * @export
 * @class EmailProvidersApi
 * @extends {BaseAPI}
 */
export class EmailProvidersApi extends BaseAPI {
    /**
     * Configure your Email Provider
     * @summary Configure Email Provider
     * @param {EmailProvider} body email-provider configuration
     * @param {string} appId ID of Passage App
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailProvidersApi
     */
    public createEmailProviderHandler(body: EmailProvider, appId: string, options?: any) {
        return EmailProvidersApiFp(this.configuration).createEmailProviderHandler(body, appId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieve your Email Provider
     * @summary Get Email Provider
     * @param {string} appId ID of Passage App
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailProvidersApi
     */
    public getEmailProviderHandler(appId: string, options?: any) {
        return EmailProvidersApiFp(this.configuration).getEmailProviderHandler(appId, options)(this.fetch, this.basePath);
    }

    /**
     * Update your Email Provider
     * @summary Update Email Provider
     * @param {EmailProvider} body email-provider configuration
     * @param {string} appId ID of Passage App
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailProvidersApi
     */
    public updateEmailProviderHandler(body: EmailProvider, appId: string, options?: any) {
        return EmailProvidersApiFp(this.configuration).updateEmailProviderHandler(body, appId, options)(this.fetch, this.basePath);
    }

}
/**
 * EmailTemplateApi - fetch parameter creator
 * @export
 */
export const EmailTemplateApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Initializes a Passage App's Email Templates
         * @summary Create Email Template
         * @param {CreateEmailTemplateRequest} body New Email Template
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailTemplateHandler(body: CreateEmailTemplateRequest, appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createEmailTemplateHandler.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling createEmailTemplateHandler.');
            }
            const localVarPath = `/apps/{app_id}/email-templates`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateEmailTemplateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a Passage App's Email Template
         * @summary Delete Email Template
         * @param {string} appId ID of Passage App
         * @param {string} templateId ID of Email Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailTemplateHandler(appId: string, templateId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling deleteEmailTemplateHandler.');
            }
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling deleteEmailTemplateHandler.');
            }
            const localVarPath = `/apps/{app_id}/email-templates/{template_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a Passage App's Email Template
         * @summary Get Email Template
         * @param {string} appId ID of Passage App
         * @param {string} templateId ID of Email Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplateHandler(appId: string, templateId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getEmailTemplateHandler.');
            }
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling getEmailTemplateHandler.');
            }
            const localVarPath = `/apps/{app_id}/email-templates/{template_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List of Passage App's Email Templates
         * @summary List Email Templates
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplatesHandler(appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling listEmailTemplatesHandler.');
            }
            const localVarPath = `/apps/{app_id}/email-templates`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a Passage App's Email Template
         * @summary Update Email Template
         * @param {string} appId ID of Passage App
         * @param {string} templateId ID of Email Template
         * @param {UpdateEmailTemplateRequest} [body] Updated Email Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailTemplateHandler(appId: string, templateId: string, body?: UpdateEmailTemplateRequest, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling updateEmailTemplateHandler.');
            }
            // verify required parameter 'templateId' is not null or undefined
            if (templateId === null || templateId === undefined) {
                throw new RequiredError('templateId','Required parameter templateId was null or undefined when calling updateEmailTemplateHandler.');
            }
            const localVarPath = `/apps/{app_id}/email-templates/{template_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateEmailTemplateRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailTemplateApi - functional programming interface
 * @export
 */
export const EmailTemplateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Initializes a Passage App's Email Templates
         * @summary Create Email Template
         * @param {CreateEmailTemplateRequest} body New Email Template
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailTemplateHandler(body: CreateEmailTemplateRequest, appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
            const localVarFetchArgs = EmailTemplateApiFetchParamCreator(configuration).createEmailTemplateHandler(body, appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a Passage App's Email Template
         * @summary Delete Email Template
         * @param {string} appId ID of Passage App
         * @param {string} templateId ID of Email Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailTemplateHandler(appId: string, templateId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EmailTemplateApiFetchParamCreator(configuration).deleteEmailTemplateHandler(appId, templateId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a Passage App's Email Template
         * @summary Get Email Template
         * @param {string} appId ID of Passage App
         * @param {string} templateId ID of Email Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplateHandler(appId: string, templateId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse2001> {
            const localVarFetchArgs = EmailTemplateApiFetchParamCreator(configuration).getEmailTemplateHandler(appId, templateId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List of Passage App's Email Templates
         * @summary List Email Templates
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplatesHandler(appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
            const localVarFetchArgs = EmailTemplateApiFetchParamCreator(configuration).listEmailTemplatesHandler(appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a Passage App's Email Template
         * @summary Update Email Template
         * @param {string} appId ID of Passage App
         * @param {string} templateId ID of Email Template
         * @param {UpdateEmailTemplateRequest} [body] Updated Email Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailTemplateHandler(appId: string, templateId: string, body?: UpdateEmailTemplateRequest, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<InlineResponse201> {
            const localVarFetchArgs = EmailTemplateApiFetchParamCreator(configuration).updateEmailTemplateHandler(appId, templateId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmailTemplateApi - factory interface
 * @export
 */
export const EmailTemplateApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Initializes a Passage App's Email Templates
         * @summary Create Email Template
         * @param {CreateEmailTemplateRequest} body New Email Template
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmailTemplateHandler(body: CreateEmailTemplateRequest, appId: string, options?: any) {
            return EmailTemplateApiFp(configuration).createEmailTemplateHandler(body, appId, options)(fetch, basePath);
        },
        /**
         * Deletes a Passage App's Email Template
         * @summary Delete Email Template
         * @param {string} appId ID of Passage App
         * @param {string} templateId ID of Email Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmailTemplateHandler(appId: string, templateId: string, options?: any) {
            return EmailTemplateApiFp(configuration).deleteEmailTemplateHandler(appId, templateId, options)(fetch, basePath);
        },
        /**
         * Returns a Passage App's Email Template
         * @summary Get Email Template
         * @param {string} appId ID of Passage App
         * @param {string} templateId ID of Email Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmailTemplateHandler(appId: string, templateId: string, options?: any) {
            return EmailTemplateApiFp(configuration).getEmailTemplateHandler(appId, templateId, options)(fetch, basePath);
        },
        /**
         * List of Passage App's Email Templates
         * @summary List Email Templates
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEmailTemplatesHandler(appId: string, options?: any) {
            return EmailTemplateApiFp(configuration).listEmailTemplatesHandler(appId, options)(fetch, basePath);
        },
        /**
         * Updates a Passage App's Email Template
         * @summary Update Email Template
         * @param {string} appId ID of Passage App
         * @param {string} templateId ID of Email Template
         * @param {UpdateEmailTemplateRequest} [body] Updated Email Template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmailTemplateHandler(appId: string, templateId: string, body?: UpdateEmailTemplateRequest, options?: any) {
            return EmailTemplateApiFp(configuration).updateEmailTemplateHandler(appId, templateId, body, options)(fetch, basePath);
        },
    };
};

/**
 * EmailTemplateApi - object-oriented interface
 * @export
 * @class EmailTemplateApi
 * @extends {BaseAPI}
 */
export class EmailTemplateApi extends BaseAPI {
    /**
     * Initializes a Passage App's Email Templates
     * @summary Create Email Template
     * @param {CreateEmailTemplateRequest} body New Email Template
     * @param {string} appId ID of Passage App
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailTemplateApi
     */
    public createEmailTemplateHandler(body: CreateEmailTemplateRequest, appId: string, options?: any) {
        return EmailTemplateApiFp(this.configuration).createEmailTemplateHandler(body, appId, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a Passage App's Email Template
     * @summary Delete Email Template
     * @param {string} appId ID of Passage App
     * @param {string} templateId ID of Email Template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailTemplateApi
     */
    public deleteEmailTemplateHandler(appId: string, templateId: string, options?: any) {
        return EmailTemplateApiFp(this.configuration).deleteEmailTemplateHandler(appId, templateId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a Passage App's Email Template
     * @summary Get Email Template
     * @param {string} appId ID of Passage App
     * @param {string} templateId ID of Email Template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailTemplateApi
     */
    public getEmailTemplateHandler(appId: string, templateId: string, options?: any) {
        return EmailTemplateApiFp(this.configuration).getEmailTemplateHandler(appId, templateId, options)(this.fetch, this.basePath);
    }

    /**
     * List of Passage App's Email Templates
     * @summary List Email Templates
     * @param {string} appId ID of Passage App
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailTemplateApi
     */
    public listEmailTemplatesHandler(appId: string, options?: any) {
        return EmailTemplateApiFp(this.configuration).listEmailTemplatesHandler(appId, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a Passage App's Email Template
     * @summary Update Email Template
     * @param {string} appId ID of Passage App
     * @param {string} templateId ID of Email Template
     * @param {UpdateEmailTemplateRequest} [body] Updated Email Template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailTemplateApi
     */
    public updateEmailTemplateHandler(appId: string, templateId: string, body?: UpdateEmailTemplateRequest, options?: any) {
        return EmailTemplateApiFp(this.configuration).updateEmailTemplateHandler(appId, templateId, body, options)(this.fetch, this.basePath);
    }

}
/**
 * EmailTestApi - fetch parameter creator
 * @export
 */
export const EmailTestApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send a test email
         * @summary Send a test email
         * @param {SendEmailRequest} body email send settings
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestEmailHandler(body: SendEmailRequest, appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendTestEmailHandler.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling sendTestEmailHandler.');
            }
            const localVarPath = `/apps/{app_id}/email-test`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SendEmailRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailTestApi - functional programming interface
 * @export
 */
export const EmailTestApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Send a test email
         * @summary Send a test email
         * @param {SendEmailRequest} body email send settings
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestEmailHandler(body: SendEmailRequest, appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EmailTestApiFetchParamCreator(configuration).sendTestEmailHandler(body, appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmailTestApi - factory interface
 * @export
 */
export const EmailTestApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Send a test email
         * @summary Send a test email
         * @param {SendEmailRequest} body email send settings
         * @param {string} appId ID of Passage App
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendTestEmailHandler(body: SendEmailRequest, appId: string, options?: any) {
            return EmailTestApiFp(configuration).sendTestEmailHandler(body, appId, options)(fetch, basePath);
        },
    };
};

/**
 * EmailTestApi - object-oriented interface
 * @export
 * @class EmailTestApi
 * @extends {BaseAPI}
 */
export class EmailTestApi extends BaseAPI {
    /**
     * Send a test email
     * @summary Send a test email
     * @param {SendEmailRequest} body email send settings
     * @param {string} appId ID of Passage App
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailTestApi
     */
    public sendTestEmailHandler(body: SendEmailRequest, appId: string, options?: any) {
        return EmailTestApiFp(this.configuration).sendTestEmailHandler(body, appId, options)(this.fetch, this.basePath);
    }

}
/**
 * EventsApi - fetch parameter creator
 * @export
 */
export const EventsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get information about an event.
         * @summary Get Event
         * @param {string} appId App ID
         * @param {string} eventId event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(appId: string, eventId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getEvent.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling getEvent.');
            }
            const localVarPath = `/apps/{app_id}/events/{event_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"event_id"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List paginated events for an app.
         * @summary List Paginated Events
         * @param {string} appId App ID
         * @param {number} [page] page to fetch (min&#x3D;1)
         * @param {number} [limit] number of events to fetch per page (max&#x3D;500)
         * @param {number} [createdBefore] Unix timestamp to anchor pagination results (fetches events that were created before the timestamp)
         * @param {string} [orderBy] Comma separated list of &lt;field&gt;:&lt;ASC/DESC&gt; (example: order_by&#x3D;id:DESC,created_at:ASC)
         * @param {string} [id] search event id (pagination prepended operators id&#x3D;&lt;val&gt;, id&#x3D;&lt;ne:val&gt;, id&#x3D;&lt;gt:val&gt;, id&#x3D;&lt;lt:val&gt;, id&#x3D;&lt;like:&gt;, id&#x3D;&lt;not_like:&gt;)
         * @param {string} [identifier] search event identifier (pagination prepended operators identifier&#x3D;&lt;val&gt;, identifier&#x3D;&lt;ne:val&gt;, identifier&#x3D;&lt;gt:val&gt;, identifier&#x3D;&lt;lt:val&gt;, identifier&#x3D;&lt;like:&gt;, identifier&#x3D;&lt;not_like:&gt;)
         * @param {string} [userId] search event user_id (pagination prepended operators user_id&#x3D;&lt;val&gt;, user_id&#x3D;&lt;ne:val&gt;, user_id&#x3D;&lt;gt:val&gt;, user_id&#x3D;&lt;lt:val&gt;, user_id&#x3D;&lt;like:&gt;, user_id&#x3D;&lt;not_like:&gt;)
         * @param {string} [type] search event type (pagination prepended operators type&#x3D;&lt;val&gt;, type&#x3D;&lt;ne:val&gt;, type&#x3D;&lt;gt:val&gt;, type&#x3D;&lt;lt:val&gt;, type&#x3D;&lt;like:&gt;, type&#x3D;&lt;not_like:&gt;) -- valid values: (webauthn.register.initiated, webauthn.register.completed, webauthn.login.initiated, webauthn.login.completed, magic_link.register.initiated, magic_link.login.initiated, magic_link.completed)
         * @param {string} [ipAddr] search event ip_addr (pagination prepended operators ip_addr&#x3D;&lt;val&gt;, ip_addr&#x3D;&lt;ne:val&gt;, ip_addr&#x3D;&lt;gt:val&gt;, ip_addr&#x3D;&lt;lt:val&gt;, ip_addr&#x3D;&lt;like:&gt;, ip_addr&#x3D;&lt;not_like:&gt;)
         * @param {string} [userAgent] search event user_agent (pagination prepended operators user_agent&#x3D;&lt;val&gt;, user_agent&#x3D;&lt;ne:val&gt;, user_agent&#x3D;&lt;gt:val&gt;, user_agent&#x3D;&lt;lt:val&gt;, user_agent&#x3D;&lt;like:&gt;, user_agent&#x3D;&lt;not_like:&gt;)
         * @param {string} [createdAt] search event created_at (pagination prepended operators created_at&#x3D;&lt;val&gt;, created_at&#x3D;&lt;ne:val&gt;, created_at&#x3D;&lt;gt:val&gt;, created_at&#x3D;&lt;lt:val&gt; -- valid timestamp in the format: 2006-01-02T15:04:05.000000Z required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaginatedEvents(appId: string, page?: number, limit?: number, createdBefore?: number, orderBy?: string, id?: string, identifier?: string, userId?: string, type?: string, ipAddr?: string, userAgent?: string, createdAt?: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling listPaginatedEvents.');
            }
            const localVarPath = `/apps/{app_id}/events`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = createdBefore;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (identifier !== undefined) {
                localVarQueryParameter['identifier'] = identifier;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (ipAddr !== undefined) {
                localVarQueryParameter['ip_addr'] = ipAddr;
            }

            if (userAgent !== undefined) {
                localVarQueryParameter['user_agent'] = userAgent;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get information about an event.
         * @summary Get Event
         * @param {string} appId App ID
         * @param {string} eventId event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(appId: string, eventId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EventResponse> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).getEvent(appId, eventId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List paginated events for an app.
         * @summary List Paginated Events
         * @param {string} appId App ID
         * @param {number} [page] page to fetch (min&#x3D;1)
         * @param {number} [limit] number of events to fetch per page (max&#x3D;500)
         * @param {number} [createdBefore] Unix timestamp to anchor pagination results (fetches events that were created before the timestamp)
         * @param {string} [orderBy] Comma separated list of &lt;field&gt;:&lt;ASC/DESC&gt; (example: order_by&#x3D;id:DESC,created_at:ASC)
         * @param {string} [id] search event id (pagination prepended operators id&#x3D;&lt;val&gt;, id&#x3D;&lt;ne:val&gt;, id&#x3D;&lt;gt:val&gt;, id&#x3D;&lt;lt:val&gt;, id&#x3D;&lt;like:&gt;, id&#x3D;&lt;not_like:&gt;)
         * @param {string} [identifier] search event identifier (pagination prepended operators identifier&#x3D;&lt;val&gt;, identifier&#x3D;&lt;ne:val&gt;, identifier&#x3D;&lt;gt:val&gt;, identifier&#x3D;&lt;lt:val&gt;, identifier&#x3D;&lt;like:&gt;, identifier&#x3D;&lt;not_like:&gt;)
         * @param {string} [userId] search event user_id (pagination prepended operators user_id&#x3D;&lt;val&gt;, user_id&#x3D;&lt;ne:val&gt;, user_id&#x3D;&lt;gt:val&gt;, user_id&#x3D;&lt;lt:val&gt;, user_id&#x3D;&lt;like:&gt;, user_id&#x3D;&lt;not_like:&gt;)
         * @param {string} [type] search event type (pagination prepended operators type&#x3D;&lt;val&gt;, type&#x3D;&lt;ne:val&gt;, type&#x3D;&lt;gt:val&gt;, type&#x3D;&lt;lt:val&gt;, type&#x3D;&lt;like:&gt;, type&#x3D;&lt;not_like:&gt;) -- valid values: (webauthn.register.initiated, webauthn.register.completed, webauthn.login.initiated, webauthn.login.completed, magic_link.register.initiated, magic_link.login.initiated, magic_link.completed)
         * @param {string} [ipAddr] search event ip_addr (pagination prepended operators ip_addr&#x3D;&lt;val&gt;, ip_addr&#x3D;&lt;ne:val&gt;, ip_addr&#x3D;&lt;gt:val&gt;, ip_addr&#x3D;&lt;lt:val&gt;, ip_addr&#x3D;&lt;like:&gt;, ip_addr&#x3D;&lt;not_like:&gt;)
         * @param {string} [userAgent] search event user_agent (pagination prepended operators user_agent&#x3D;&lt;val&gt;, user_agent&#x3D;&lt;ne:val&gt;, user_agent&#x3D;&lt;gt:val&gt;, user_agent&#x3D;&lt;lt:val&gt;, user_agent&#x3D;&lt;like:&gt;, user_agent&#x3D;&lt;not_like:&gt;)
         * @param {string} [createdAt] search event created_at (pagination prepended operators created_at&#x3D;&lt;val&gt;, created_at&#x3D;&lt;ne:val&gt;, created_at&#x3D;&lt;gt:val&gt;, created_at&#x3D;&lt;lt:val&gt; -- valid timestamp in the format: 2006-01-02T15:04:05.000000Z required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaginatedEvents(appId: string, page?: number, limit?: number, createdBefore?: number, orderBy?: string, id?: string, identifier?: string, userId?: string, type?: string, ipAddr?: string, userAgent?: string, createdAt?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListPaginatedEventsResponse> {
            const localVarFetchArgs = EventsApiFetchParamCreator(configuration).listPaginatedEvents(appId, page, limit, createdBefore, orderBy, id, identifier, userId, type, ipAddr, userAgent, createdAt, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get information about an event.
         * @summary Get Event
         * @param {string} appId App ID
         * @param {string} eventId event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEvent(appId: string, eventId: string, options?: any) {
            return EventsApiFp(configuration).getEvent(appId, eventId, options)(fetch, basePath);
        },
        /**
         * List paginated events for an app.
         * @summary List Paginated Events
         * @param {string} appId App ID
         * @param {number} [page] page to fetch (min&#x3D;1)
         * @param {number} [limit] number of events to fetch per page (max&#x3D;500)
         * @param {number} [createdBefore] Unix timestamp to anchor pagination results (fetches events that were created before the timestamp)
         * @param {string} [orderBy] Comma separated list of &lt;field&gt;:&lt;ASC/DESC&gt; (example: order_by&#x3D;id:DESC,created_at:ASC)
         * @param {string} [id] search event id (pagination prepended operators id&#x3D;&lt;val&gt;, id&#x3D;&lt;ne:val&gt;, id&#x3D;&lt;gt:val&gt;, id&#x3D;&lt;lt:val&gt;, id&#x3D;&lt;like:&gt;, id&#x3D;&lt;not_like:&gt;)
         * @param {string} [identifier] search event identifier (pagination prepended operators identifier&#x3D;&lt;val&gt;, identifier&#x3D;&lt;ne:val&gt;, identifier&#x3D;&lt;gt:val&gt;, identifier&#x3D;&lt;lt:val&gt;, identifier&#x3D;&lt;like:&gt;, identifier&#x3D;&lt;not_like:&gt;)
         * @param {string} [userId] search event user_id (pagination prepended operators user_id&#x3D;&lt;val&gt;, user_id&#x3D;&lt;ne:val&gt;, user_id&#x3D;&lt;gt:val&gt;, user_id&#x3D;&lt;lt:val&gt;, user_id&#x3D;&lt;like:&gt;, user_id&#x3D;&lt;not_like:&gt;)
         * @param {string} [type] search event type (pagination prepended operators type&#x3D;&lt;val&gt;, type&#x3D;&lt;ne:val&gt;, type&#x3D;&lt;gt:val&gt;, type&#x3D;&lt;lt:val&gt;, type&#x3D;&lt;like:&gt;, type&#x3D;&lt;not_like:&gt;) -- valid values: (webauthn.register.initiated, webauthn.register.completed, webauthn.login.initiated, webauthn.login.completed, magic_link.register.initiated, magic_link.login.initiated, magic_link.completed)
         * @param {string} [ipAddr] search event ip_addr (pagination prepended operators ip_addr&#x3D;&lt;val&gt;, ip_addr&#x3D;&lt;ne:val&gt;, ip_addr&#x3D;&lt;gt:val&gt;, ip_addr&#x3D;&lt;lt:val&gt;, ip_addr&#x3D;&lt;like:&gt;, ip_addr&#x3D;&lt;not_like:&gt;)
         * @param {string} [userAgent] search event user_agent (pagination prepended operators user_agent&#x3D;&lt;val&gt;, user_agent&#x3D;&lt;ne:val&gt;, user_agent&#x3D;&lt;gt:val&gt;, user_agent&#x3D;&lt;lt:val&gt;, user_agent&#x3D;&lt;like:&gt;, user_agent&#x3D;&lt;not_like:&gt;)
         * @param {string} [createdAt] search event created_at (pagination prepended operators created_at&#x3D;&lt;val&gt;, created_at&#x3D;&lt;ne:val&gt;, created_at&#x3D;&lt;gt:val&gt;, created_at&#x3D;&lt;lt:val&gt; -- valid timestamp in the format: 2006-01-02T15:04:05.000000Z required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaginatedEvents(appId: string, page?: number, limit?: number, createdBefore?: number, orderBy?: string, id?: string, identifier?: string, userId?: string, type?: string, ipAddr?: string, userAgent?: string, createdAt?: string, options?: any) {
            return EventsApiFp(configuration).listPaginatedEvents(appId, page, limit, createdBefore, orderBy, id, identifier, userId, type, ipAddr, userAgent, createdAt, options)(fetch, basePath);
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * Get information about an event.
     * @summary Get Event
     * @param {string} appId App ID
     * @param {string} eventId event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getEvent(appId: string, eventId: string, options?: any) {
        return EventsApiFp(this.configuration).getEvent(appId, eventId, options)(this.fetch, this.basePath);
    }

    /**
     * List paginated events for an app.
     * @summary List Paginated Events
     * @param {string} appId App ID
     * @param {number} [page] page to fetch (min&#x3D;1)
     * @param {number} [limit] number of events to fetch per page (max&#x3D;500)
     * @param {number} [createdBefore] Unix timestamp to anchor pagination results (fetches events that were created before the timestamp)
     * @param {string} [orderBy] Comma separated list of &lt;field&gt;:&lt;ASC/DESC&gt; (example: order_by&#x3D;id:DESC,created_at:ASC)
     * @param {string} [id] search event id (pagination prepended operators id&#x3D;&lt;val&gt;, id&#x3D;&lt;ne:val&gt;, id&#x3D;&lt;gt:val&gt;, id&#x3D;&lt;lt:val&gt;, id&#x3D;&lt;like:&gt;, id&#x3D;&lt;not_like:&gt;)
     * @param {string} [identifier] search event identifier (pagination prepended operators identifier&#x3D;&lt;val&gt;, identifier&#x3D;&lt;ne:val&gt;, identifier&#x3D;&lt;gt:val&gt;, identifier&#x3D;&lt;lt:val&gt;, identifier&#x3D;&lt;like:&gt;, identifier&#x3D;&lt;not_like:&gt;)
     * @param {string} [userId] search event user_id (pagination prepended operators user_id&#x3D;&lt;val&gt;, user_id&#x3D;&lt;ne:val&gt;, user_id&#x3D;&lt;gt:val&gt;, user_id&#x3D;&lt;lt:val&gt;, user_id&#x3D;&lt;like:&gt;, user_id&#x3D;&lt;not_like:&gt;)
     * @param {string} [type] search event type (pagination prepended operators type&#x3D;&lt;val&gt;, type&#x3D;&lt;ne:val&gt;, type&#x3D;&lt;gt:val&gt;, type&#x3D;&lt;lt:val&gt;, type&#x3D;&lt;like:&gt;, type&#x3D;&lt;not_like:&gt;) -- valid values: (webauthn.register.initiated, webauthn.register.completed, webauthn.login.initiated, webauthn.login.completed, magic_link.register.initiated, magic_link.login.initiated, magic_link.completed)
     * @param {string} [ipAddr] search event ip_addr (pagination prepended operators ip_addr&#x3D;&lt;val&gt;, ip_addr&#x3D;&lt;ne:val&gt;, ip_addr&#x3D;&lt;gt:val&gt;, ip_addr&#x3D;&lt;lt:val&gt;, ip_addr&#x3D;&lt;like:&gt;, ip_addr&#x3D;&lt;not_like:&gt;)
     * @param {string} [userAgent] search event user_agent (pagination prepended operators user_agent&#x3D;&lt;val&gt;, user_agent&#x3D;&lt;ne:val&gt;, user_agent&#x3D;&lt;gt:val&gt;, user_agent&#x3D;&lt;lt:val&gt;, user_agent&#x3D;&lt;like:&gt;, user_agent&#x3D;&lt;not_like:&gt;)
     * @param {string} [createdAt] search event created_at (pagination prepended operators created_at&#x3D;&lt;val&gt;, created_at&#x3D;&lt;ne:val&gt;, created_at&#x3D;&lt;gt:val&gt;, created_at&#x3D;&lt;lt:val&gt; -- valid timestamp in the format: 2006-01-02T15:04:05.000000Z required
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public listPaginatedEvents(appId: string, page?: number, limit?: number, createdBefore?: number, orderBy?: string, id?: string, identifier?: string, userId?: string, type?: string, ipAddr?: string, userAgent?: string, createdAt?: string, options?: any) {
        return EventsApiFp(this.configuration).listPaginatedEvents(appId, page, limit, createdBefore, orderBy, id, identifier, userId, type, ipAddr, userAgent, createdAt, options)(this.fetch, this.basePath);
    }

}
/**
 * MagicLinkApi - fetch parameter creator
 * @export
 */
export const MagicLinkApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create magic link for a user.
         * @summary Create Embeddable Magic Link
         * @param {CreateMagicLinkRequest} body magic link request
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMagicLink(body: CreateMagicLinkRequest, appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createMagicLink.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling createMagicLink.');
            }
            const localVarPath = `/apps/{app_id}/magic-links`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateMagicLinkRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MagicLinkApi - functional programming interface
 * @export
 */
export const MagicLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create magic link for a user.
         * @summary Create Embeddable Magic Link
         * @param {CreateMagicLinkRequest} body magic link request
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMagicLink(body: CreateMagicLinkRequest, appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MagicLinkResponse> {
            const localVarFetchArgs = MagicLinkApiFetchParamCreator(configuration).createMagicLink(body, appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MagicLinkApi - factory interface
 * @export
 */
export const MagicLinkApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create magic link for a user.
         * @summary Create Embeddable Magic Link
         * @param {CreateMagicLinkRequest} body magic link request
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMagicLink(body: CreateMagicLinkRequest, appId: string, options?: any) {
            return MagicLinkApiFp(configuration).createMagicLink(body, appId, options)(fetch, basePath);
        },
    };
};

/**
 * MagicLinkApi - object-oriented interface
 * @export
 * @class MagicLinkApi
 * @extends {BaseAPI}
 */
export class MagicLinkApi extends BaseAPI {
    /**
     * Create magic link for a user.
     * @summary Create Embeddable Magic Link
     * @param {CreateMagicLinkRequest} body magic link request
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MagicLinkApi
     */
    public createMagicLink(body: CreateMagicLinkRequest, appId: string, options?: any) {
        return MagicLinkApiFp(this.configuration).createMagicLink(body, appId, options)(this.fetch, this.basePath);
    }

}
/**
 * TokensApi - fetch parameter creator
 * @export
 */
export const TokensApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Revokes all refresh tokens for a user
         * @summary Revokes refresh tokens
         * @param {string} appId App ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserRefreshTokens(appId: string, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling revokeUserRefreshTokens.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling revokeUserRefreshTokens.');
            }
            const localVarPath = `/apps/{app_id}/users/{user_id}/tokens`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokensApi - functional programming interface
 * @export
 */
export const TokensApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Revokes all refresh tokens for a user
         * @summary Revokes refresh tokens
         * @param {string} appId App ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserRefreshTokens(appId: string, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TokensApiFetchParamCreator(configuration).revokeUserRefreshTokens(appId, userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TokensApi - factory interface
 * @export
 */
export const TokensApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Revokes all refresh tokens for a user
         * @summary Revokes refresh tokens
         * @param {string} appId App ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeUserRefreshTokens(appId: string, userId: string, options?: any) {
            return TokensApiFp(configuration).revokeUserRefreshTokens(appId, userId, options)(fetch, basePath);
        },
    };
};

/**
 * TokensApi - object-oriented interface
 * @export
 * @class TokensApi
 * @extends {BaseAPI}
 */
export class TokensApi extends BaseAPI {
    /**
     * Revokes all refresh tokens for a user
     * @summary Revokes refresh tokens
     * @param {string} appId App ID
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokensApi
     */
    public revokeUserRefreshTokens(appId: string, userId: string, options?: any) {
        return TokensApiFp(this.configuration).revokeUserRefreshTokens(appId, userId, options)(this.fetch, this.basePath);
    }

}
/**
 * UserDevicesApi - fetch parameter creator
 * @export
 */
export const UserDevicesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete a device for a user.
         * @summary Delete a device for a user
         * @param {string} appId App ID
         * @param {string} userId User ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserDevices(appId: string, userId: string, deviceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling deleteUserDevices.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserDevices.');
            }
            // verify required parameter 'deviceId' is not null or undefined
            if (deviceId === null || deviceId === undefined) {
                throw new RequiredError('deviceId','Required parameter deviceId was null or undefined when calling deleteUserDevices.');
            }
            const localVarPath = `/apps/{app_id}/users/{user_id}/devices/{device_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"device_id"}}`, encodeURIComponent(String(deviceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List user devices.
         * @summary List User Devices
         * @param {string} appId App ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserDevices(appId: string, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling listUserDevices.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling listUserDevices.');
            }
            const localVarPath = `/apps/{app_id}/users/{user_id}/devices`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserDevicesApi - functional programming interface
 * @export
 */
export const UserDevicesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete a device for a user.
         * @summary Delete a device for a user
         * @param {string} appId App ID
         * @param {string} userId User ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserDevices(appId: string, userId: string, deviceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserDevicesApiFetchParamCreator(configuration).deleteUserDevices(appId, userId, deviceId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List user devices.
         * @summary List User Devices
         * @param {string} appId App ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserDevices(appId: string, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListDevicesResponse> {
            const localVarFetchArgs = UserDevicesApiFetchParamCreator(configuration).listUserDevices(appId, userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserDevicesApi - factory interface
 * @export
 */
export const UserDevicesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Delete a device for a user.
         * @summary Delete a device for a user
         * @param {string} appId App ID
         * @param {string} userId User ID
         * @param {string} deviceId Device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserDevices(appId: string, userId: string, deviceId: string, options?: any) {
            return UserDevicesApiFp(configuration).deleteUserDevices(appId, userId, deviceId, options)(fetch, basePath);
        },
        /**
         * List user devices.
         * @summary List User Devices
         * @param {string} appId App ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserDevices(appId: string, userId: string, options?: any) {
            return UserDevicesApiFp(configuration).listUserDevices(appId, userId, options)(fetch, basePath);
        },
    };
};

/**
 * UserDevicesApi - object-oriented interface
 * @export
 * @class UserDevicesApi
 * @extends {BaseAPI}
 */
export class UserDevicesApi extends BaseAPI {
    /**
     * Delete a device for a user.
     * @summary Delete a device for a user
     * @param {string} appId App ID
     * @param {string} userId User ID
     * @param {string} deviceId Device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDevicesApi
     */
    public deleteUserDevices(appId: string, userId: string, deviceId: string, options?: any) {
        return UserDevicesApiFp(this.configuration).deleteUserDevices(appId, userId, deviceId, options)(this.fetch, this.basePath);
    }

    /**
     * List user devices.
     * @summary List User Devices
     * @param {string} appId App ID
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserDevicesApi
     */
    public listUserDevices(appId: string, userId: string, options?: any) {
        return UserDevicesApiFp(this.configuration).listUserDevices(appId, userId, options)(this.fetch, this.basePath);
    }

}
/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Activate a user. They will now be able to login.
         * @summary Activate User
         * @param {string} appId App ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser(appId: string, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling activateUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling activateUser.');
            }
            const localVarPath = `/apps/{app_id}/users/{user_id}/activate`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create user for an application. Must provide an email of phone number identifier.
         * @summary Create User
         * @param {CreateUserRequest} body email, phone, user_metadata
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: CreateUserRequest, appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createUser.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling createUser.');
            }
            const localVarPath = `/apps/{app_id}/users`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CreateUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate a user. Their account will still exist, but they will not be able to login.
         * @summary Deactivate User
         * @param {string} appId App ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUser(appId: string, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling deactivateUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deactivateUser.');
            }
            const localVarPath = `/apps/{app_id}/users/{user_id}/deactivate`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user.
         * @summary Delete User
         * @param {string} appId App ID
         * @param {string} userId user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(appId: string, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling deleteUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/apps/{app_id}/users/{user_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a user.
         * @summary Get User
         * @param {string} appId App ID
         * @param {string} userId user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(appId: string, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling getUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUser.');
            }
            const localVarPath = `/apps/{app_id}/users/{user_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk upload users for an application. Files must be in valid CSV format and no more than 30k users.
         * @summary Import Users
         * @param {Blob} csvUserImport 
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUsers(csvUserImport: Blob, appId: string, options: any = {}): FetchArgs {
            // verify required parameter 'csvUserImport' is not null or undefined
            if (csvUserImport === null || csvUserImport === undefined) {
                throw new RequiredError('csvUserImport','Required parameter csvUserImport was null or undefined when calling importUsers.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling importUsers.');
            }
            const localVarPath = `/apps/{app_id}/import/users`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication bearerAuth required

            if (csvUserImport !== undefined) {
                localVarFormParams.set('csv_user_import', csvUserImport as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List users for an app.
         * @summary List Users
         * @param {string} appId App ID
         * @param {number} [page] page to fetch (min&#x3D;1)
         * @param {number} [limit] number of users to fetch per page (max&#x3D;500)
         * @param {number} [createdBefore] Unix timestamp to anchor pagination results (fetches events that were created before the timestamp)
         * @param {string} [orderBy] Comma separated list of &lt;field&gt;:&lt;ASC/DESC&gt; (example: order_by&#x3D;id:DESC,created_at:ASC) **cannot order_by &#x60;identifier&#x60;
         * @param {string} [identifier] search users email OR phone (pagination prepended operators identifier&#x3D;&lt;val&gt;, identifier&#x3D;&lt;ne:val&gt;, identifier&#x3D;&lt;gt:val&gt;, identifier&#x3D;&lt;lt:val&gt;, identifier&#x3D;&lt;like:val&gt;, identifier&#x3D;&lt;not_like:val&gt;)
         * @param {string} [id] search users id (pagination prepended operators id&#x3D;&lt;val&gt;, id&#x3D;&lt;ne:val&gt;, id&#x3D;&lt;gt:val&gt;, id&#x3D;&lt;lt:val&gt;, id&#x3D;&lt;like:val&gt;, id&#x3D;&lt;not_like:val&gt;)
         * @param {number} [loginCount] search users login_count (pagination prepended operators login_count&#x3D;&lt;val&gt;, login_count&#x3D;&lt;ne:val&gt;, login_count&#x3D;&lt;gt:val&gt;, login_count&#x3D;&lt;lt:val&gt;)
         * @param {string} [status] search users by status (pagination prepended operators status&#x3D;&lt;val&gt;, status&#x3D;&lt;ne:val&gt;, status&#x3D;&lt;gt:val&gt;, status&#x3D;&lt;lt:val&gt;, status&#x3D;&lt;like:val&gt;, status&#x3D;&lt;not_like:val&gt;) -- valid values: (active, inactive, pending)
         * @param {boolean} [emailVerified] search users email_verified (pagination prepended operators email_verified&#x3D;&lt;val&gt;, email_verified&#x3D;&lt;ne:val&gt;, email_verified&#x3D;&lt;gt:val&gt;, email_verified&#x3D;&lt;lt:val&gt;)
         * @param {string} [createdAt] search users created_at (pagination prepended operators created_at&#x3D;&lt;val&gt;, created_at&#x3D;&lt;ne:val&gt;, created_at&#x3D;&lt;gt:val&gt;, created_at&#x3D;&lt;lt:val&gt; -- valid timestamp in the format: 2006-01-02T15:04:05.000000Z required
         * @param {string} [updatedAt] search users updated_at (pagination prepended operators updated_at&#x3D;&lt;val&gt;, updated_at&#x3D;&lt;ne:val&gt;, updated_at&#x3D;&lt;gt:val&gt;, updated_at&#x3D;&lt;lt:val&gt; -- valid timestamp in the format: 2006-01-02T15:04:05.000000Z required
         * @param {string} [lastLoginAt] search users last_login_at (pagination prepended operators last_login_at&#x3D;&lt;val&gt;, lat_login_at&#x3D;&lt;ne:val&gt;, last_login_at&#x3D;&lt;gt:val&gt;, last_login_at&#x3D;&lt;lt:val&gt; -- valid timestamp in the format: 2006-01-02T15:04:05.000000Z required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaginatedUsers(appId: string, page?: number, limit?: number, createdBefore?: number, orderBy?: string, identifier?: string, id?: string, loginCount?: number, status?: string, emailVerified?: boolean, createdAt?: string, updatedAt?: string, lastLoginAt?: string, options: any = {}): FetchArgs {
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling listPaginatedUsers.');
            }
            const localVarPath = `/apps/{app_id}/users`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['created_before'] = createdBefore;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['order_by'] = orderBy;
            }

            if (identifier !== undefined) {
                localVarQueryParameter['identifier'] = identifier;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (loginCount !== undefined) {
                localVarQueryParameter['login_count'] = loginCount;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (emailVerified !== undefined) {
                localVarQueryParameter['email_verified'] = emailVerified;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }

            if (lastLoginAt !== undefined) {
                localVarQueryParameter['last_login_at'] = lastLoginAt;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user's information.
         * @summary Update User
         * @param {UpdateUserRequest} body user settings
         * @param {string} appId App ID
         * @param {string} userId user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UpdateUserRequest, appId: string, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUser.');
            }
            // verify required parameter 'appId' is not null or undefined
            if (appId === null || appId === undefined) {
                throw new RequiredError('appId','Required parameter appId was null or undefined when calling updateUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUser.');
            }
            const localVarPath = `/apps/{app_id}/users/{user_id}`
                .replace(`{${"app_id"}}`, encodeURIComponent(String(appId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PATCH' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UpdateUserRequest" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Activate a user. They will now be able to login.
         * @summary Activate User
         * @param {string} appId App ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser(appId: string, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).activateUser(appId, userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create user for an application. Must provide an email of phone number identifier.
         * @summary Create User
         * @param {CreateUserRequest} body email, phone, user_metadata
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: CreateUserRequest, appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).createUser(body, appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deactivate a user. Their account will still exist, but they will not be able to login.
         * @summary Deactivate User
         * @param {string} appId App ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUser(appId: string, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deactivateUser(appId, userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a user.
         * @summary Delete User
         * @param {string} appId App ID
         * @param {string} userId user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(appId: string, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deleteUser(appId, userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get information about a user.
         * @summary Get User
         * @param {string} appId App ID
         * @param {string} userId user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(appId: string, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUser(appId, userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Bulk upload users for an application. Files must be in valid CSV format and no more than 30k users.
         * @summary Import Users
         * @param {Blob} csvUserImport 
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUsers(csvUserImport: Blob, appId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserCSVImportResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).importUsers(csvUserImport, appId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List users for an app.
         * @summary List Users
         * @param {string} appId App ID
         * @param {number} [page] page to fetch (min&#x3D;1)
         * @param {number} [limit] number of users to fetch per page (max&#x3D;500)
         * @param {number} [createdBefore] Unix timestamp to anchor pagination results (fetches events that were created before the timestamp)
         * @param {string} [orderBy] Comma separated list of &lt;field&gt;:&lt;ASC/DESC&gt; (example: order_by&#x3D;id:DESC,created_at:ASC) **cannot order_by &#x60;identifier&#x60;
         * @param {string} [identifier] search users email OR phone (pagination prepended operators identifier&#x3D;&lt;val&gt;, identifier&#x3D;&lt;ne:val&gt;, identifier&#x3D;&lt;gt:val&gt;, identifier&#x3D;&lt;lt:val&gt;, identifier&#x3D;&lt;like:val&gt;, identifier&#x3D;&lt;not_like:val&gt;)
         * @param {string} [id] search users id (pagination prepended operators id&#x3D;&lt;val&gt;, id&#x3D;&lt;ne:val&gt;, id&#x3D;&lt;gt:val&gt;, id&#x3D;&lt;lt:val&gt;, id&#x3D;&lt;like:val&gt;, id&#x3D;&lt;not_like:val&gt;)
         * @param {number} [loginCount] search users login_count (pagination prepended operators login_count&#x3D;&lt;val&gt;, login_count&#x3D;&lt;ne:val&gt;, login_count&#x3D;&lt;gt:val&gt;, login_count&#x3D;&lt;lt:val&gt;)
         * @param {string} [status] search users by status (pagination prepended operators status&#x3D;&lt;val&gt;, status&#x3D;&lt;ne:val&gt;, status&#x3D;&lt;gt:val&gt;, status&#x3D;&lt;lt:val&gt;, status&#x3D;&lt;like:val&gt;, status&#x3D;&lt;not_like:val&gt;) -- valid values: (active, inactive, pending)
         * @param {boolean} [emailVerified] search users email_verified (pagination prepended operators email_verified&#x3D;&lt;val&gt;, email_verified&#x3D;&lt;ne:val&gt;, email_verified&#x3D;&lt;gt:val&gt;, email_verified&#x3D;&lt;lt:val&gt;)
         * @param {string} [createdAt] search users created_at (pagination prepended operators created_at&#x3D;&lt;val&gt;, created_at&#x3D;&lt;ne:val&gt;, created_at&#x3D;&lt;gt:val&gt;, created_at&#x3D;&lt;lt:val&gt; -- valid timestamp in the format: 2006-01-02T15:04:05.000000Z required
         * @param {string} [updatedAt] search users updated_at (pagination prepended operators updated_at&#x3D;&lt;val&gt;, updated_at&#x3D;&lt;ne:val&gt;, updated_at&#x3D;&lt;gt:val&gt;, updated_at&#x3D;&lt;lt:val&gt; -- valid timestamp in the format: 2006-01-02T15:04:05.000000Z required
         * @param {string} [lastLoginAt] search users last_login_at (pagination prepended operators last_login_at&#x3D;&lt;val&gt;, lat_login_at&#x3D;&lt;ne:val&gt;, last_login_at&#x3D;&lt;gt:val&gt;, last_login_at&#x3D;&lt;lt:val&gt; -- valid timestamp in the format: 2006-01-02T15:04:05.000000Z required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaginatedUsers(appId: string, page?: number, limit?: number, createdBefore?: number, orderBy?: string, identifier?: string, id?: string, loginCount?: number, status?: string, emailVerified?: boolean, createdAt?: string, updatedAt?: string, lastLoginAt?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ListPaginatedUsersResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).listPaginatedUsers(appId, page, limit, createdBefore, orderBy, identifier, id, loginCount, status, emailVerified, createdAt, updatedAt, lastLoginAt, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a user's information.
         * @summary Update User
         * @param {UpdateUserRequest} body user settings
         * @param {string} appId App ID
         * @param {string} userId user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UpdateUserRequest, appId: string, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUser(body, appId, userId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Activate a user. They will now be able to login.
         * @summary Activate User
         * @param {string} appId App ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        activateUser(appId: string, userId: string, options?: any) {
            return UsersApiFp(configuration).activateUser(appId, userId, options)(fetch, basePath);
        },
        /**
         * Create user for an application. Must provide an email of phone number identifier.
         * @summary Create User
         * @param {CreateUserRequest} body email, phone, user_metadata
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: CreateUserRequest, appId: string, options?: any) {
            return UsersApiFp(configuration).createUser(body, appId, options)(fetch, basePath);
        },
        /**
         * Deactivate a user. Their account will still exist, but they will not be able to login.
         * @summary Deactivate User
         * @param {string} appId App ID
         * @param {string} userId User ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateUser(appId: string, userId: string, options?: any) {
            return UsersApiFp(configuration).deactivateUser(appId, userId, options)(fetch, basePath);
        },
        /**
         * Delete a user.
         * @summary Delete User
         * @param {string} appId App ID
         * @param {string} userId user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(appId: string, userId: string, options?: any) {
            return UsersApiFp(configuration).deleteUser(appId, userId, options)(fetch, basePath);
        },
        /**
         * Get information about a user.
         * @summary Get User
         * @param {string} appId App ID
         * @param {string} userId user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(appId: string, userId: string, options?: any) {
            return UsersApiFp(configuration).getUser(appId, userId, options)(fetch, basePath);
        },
        /**
         * Bulk upload users for an application. Files must be in valid CSV format and no more than 30k users.
         * @summary Import Users
         * @param {Blob} csvUserImport 
         * @param {string} appId App ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importUsers(csvUserImport: Blob, appId: string, options?: any) {
            return UsersApiFp(configuration).importUsers(csvUserImport, appId, options)(fetch, basePath);
        },
        /**
         * List users for an app.
         * @summary List Users
         * @param {string} appId App ID
         * @param {number} [page] page to fetch (min&#x3D;1)
         * @param {number} [limit] number of users to fetch per page (max&#x3D;500)
         * @param {number} [createdBefore] Unix timestamp to anchor pagination results (fetches events that were created before the timestamp)
         * @param {string} [orderBy] Comma separated list of &lt;field&gt;:&lt;ASC/DESC&gt; (example: order_by&#x3D;id:DESC,created_at:ASC) **cannot order_by &#x60;identifier&#x60;
         * @param {string} [identifier] search users email OR phone (pagination prepended operators identifier&#x3D;&lt;val&gt;, identifier&#x3D;&lt;ne:val&gt;, identifier&#x3D;&lt;gt:val&gt;, identifier&#x3D;&lt;lt:val&gt;, identifier&#x3D;&lt;like:val&gt;, identifier&#x3D;&lt;not_like:val&gt;)
         * @param {string} [id] search users id (pagination prepended operators id&#x3D;&lt;val&gt;, id&#x3D;&lt;ne:val&gt;, id&#x3D;&lt;gt:val&gt;, id&#x3D;&lt;lt:val&gt;, id&#x3D;&lt;like:val&gt;, id&#x3D;&lt;not_like:val&gt;)
         * @param {number} [loginCount] search users login_count (pagination prepended operators login_count&#x3D;&lt;val&gt;, login_count&#x3D;&lt;ne:val&gt;, login_count&#x3D;&lt;gt:val&gt;, login_count&#x3D;&lt;lt:val&gt;)
         * @param {string} [status] search users by status (pagination prepended operators status&#x3D;&lt;val&gt;, status&#x3D;&lt;ne:val&gt;, status&#x3D;&lt;gt:val&gt;, status&#x3D;&lt;lt:val&gt;, status&#x3D;&lt;like:val&gt;, status&#x3D;&lt;not_like:val&gt;) -- valid values: (active, inactive, pending)
         * @param {boolean} [emailVerified] search users email_verified (pagination prepended operators email_verified&#x3D;&lt;val&gt;, email_verified&#x3D;&lt;ne:val&gt;, email_verified&#x3D;&lt;gt:val&gt;, email_verified&#x3D;&lt;lt:val&gt;)
         * @param {string} [createdAt] search users created_at (pagination prepended operators created_at&#x3D;&lt;val&gt;, created_at&#x3D;&lt;ne:val&gt;, created_at&#x3D;&lt;gt:val&gt;, created_at&#x3D;&lt;lt:val&gt; -- valid timestamp in the format: 2006-01-02T15:04:05.000000Z required
         * @param {string} [updatedAt] search users updated_at (pagination prepended operators updated_at&#x3D;&lt;val&gt;, updated_at&#x3D;&lt;ne:val&gt;, updated_at&#x3D;&lt;gt:val&gt;, updated_at&#x3D;&lt;lt:val&gt; -- valid timestamp in the format: 2006-01-02T15:04:05.000000Z required
         * @param {string} [lastLoginAt] search users last_login_at (pagination prepended operators last_login_at&#x3D;&lt;val&gt;, lat_login_at&#x3D;&lt;ne:val&gt;, last_login_at&#x3D;&lt;gt:val&gt;, last_login_at&#x3D;&lt;lt:val&gt; -- valid timestamp in the format: 2006-01-02T15:04:05.000000Z required
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPaginatedUsers(appId: string, page?: number, limit?: number, createdBefore?: number, orderBy?: string, identifier?: string, id?: string, loginCount?: number, status?: string, emailVerified?: boolean, createdAt?: string, updatedAt?: string, lastLoginAt?: string, options?: any) {
            return UsersApiFp(configuration).listPaginatedUsers(appId, page, limit, createdBefore, orderBy, identifier, id, loginCount, status, emailVerified, createdAt, updatedAt, lastLoginAt, options)(fetch, basePath);
        },
        /**
         * Update a user's information.
         * @summary Update User
         * @param {UpdateUserRequest} body user settings
         * @param {string} appId App ID
         * @param {string} userId user ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UpdateUserRequest, appId: string, userId: string, options?: any) {
            return UsersApiFp(configuration).updateUser(body, appId, userId, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Activate a user. They will now be able to login.
     * @summary Activate User
     * @param {string} appId App ID
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public activateUser(appId: string, userId: string, options?: any) {
        return UsersApiFp(this.configuration).activateUser(appId, userId, options)(this.fetch, this.basePath);
    }

    /**
     * Create user for an application. Must provide an email of phone number identifier.
     * @summary Create User
     * @param {CreateUserRequest} body email, phone, user_metadata
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(body: CreateUserRequest, appId: string, options?: any) {
        return UsersApiFp(this.configuration).createUser(body, appId, options)(this.fetch, this.basePath);
    }

    /**
     * Deactivate a user. Their account will still exist, but they will not be able to login.
     * @summary Deactivate User
     * @param {string} appId App ID
     * @param {string} userId User ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deactivateUser(appId: string, userId: string, options?: any) {
        return UsersApiFp(this.configuration).deactivateUser(appId, userId, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a user.
     * @summary Delete User
     * @param {string} appId App ID
     * @param {string} userId user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(appId: string, userId: string, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(appId, userId, options)(this.fetch, this.basePath);
    }

    /**
     * Get information about a user.
     * @summary Get User
     * @param {string} appId App ID
     * @param {string} userId user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(appId: string, userId: string, options?: any) {
        return UsersApiFp(this.configuration).getUser(appId, userId, options)(this.fetch, this.basePath);
    }

    /**
     * Bulk upload users for an application. Files must be in valid CSV format and no more than 30k users.
     * @summary Import Users
     * @param {Blob} csvUserImport 
     * @param {string} appId App ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public importUsers(csvUserImport: Blob, appId: string, options?: any) {
        return UsersApiFp(this.configuration).importUsers(csvUserImport, appId, options)(this.fetch, this.basePath);
    }

    /**
     * List users for an app.
     * @summary List Users
     * @param {string} appId App ID
     * @param {number} [page] page to fetch (min&#x3D;1)
     * @param {number} [limit] number of users to fetch per page (max&#x3D;500)
     * @param {number} [createdBefore] Unix timestamp to anchor pagination results (fetches events that were created before the timestamp)
     * @param {string} [orderBy] Comma separated list of &lt;field&gt;:&lt;ASC/DESC&gt; (example: order_by&#x3D;id:DESC,created_at:ASC) **cannot order_by &#x60;identifier&#x60;
     * @param {string} [identifier] search users email OR phone (pagination prepended operators identifier&#x3D;&lt;val&gt;, identifier&#x3D;&lt;ne:val&gt;, identifier&#x3D;&lt;gt:val&gt;, identifier&#x3D;&lt;lt:val&gt;, identifier&#x3D;&lt;like:val&gt;, identifier&#x3D;&lt;not_like:val&gt;)
     * @param {string} [id] search users id (pagination prepended operators id&#x3D;&lt;val&gt;, id&#x3D;&lt;ne:val&gt;, id&#x3D;&lt;gt:val&gt;, id&#x3D;&lt;lt:val&gt;, id&#x3D;&lt;like:val&gt;, id&#x3D;&lt;not_like:val&gt;)
     * @param {number} [loginCount] search users login_count (pagination prepended operators login_count&#x3D;&lt;val&gt;, login_count&#x3D;&lt;ne:val&gt;, login_count&#x3D;&lt;gt:val&gt;, login_count&#x3D;&lt;lt:val&gt;)
     * @param {string} [status] search users by status (pagination prepended operators status&#x3D;&lt;val&gt;, status&#x3D;&lt;ne:val&gt;, status&#x3D;&lt;gt:val&gt;, status&#x3D;&lt;lt:val&gt;, status&#x3D;&lt;like:val&gt;, status&#x3D;&lt;not_like:val&gt;) -- valid values: (active, inactive, pending)
     * @param {boolean} [emailVerified] search users email_verified (pagination prepended operators email_verified&#x3D;&lt;val&gt;, email_verified&#x3D;&lt;ne:val&gt;, email_verified&#x3D;&lt;gt:val&gt;, email_verified&#x3D;&lt;lt:val&gt;)
     * @param {string} [createdAt] search users created_at (pagination prepended operators created_at&#x3D;&lt;val&gt;, created_at&#x3D;&lt;ne:val&gt;, created_at&#x3D;&lt;gt:val&gt;, created_at&#x3D;&lt;lt:val&gt; -- valid timestamp in the format: 2006-01-02T15:04:05.000000Z required
     * @param {string} [updatedAt] search users updated_at (pagination prepended operators updated_at&#x3D;&lt;val&gt;, updated_at&#x3D;&lt;ne:val&gt;, updated_at&#x3D;&lt;gt:val&gt;, updated_at&#x3D;&lt;lt:val&gt; -- valid timestamp in the format: 2006-01-02T15:04:05.000000Z required
     * @param {string} [lastLoginAt] search users last_login_at (pagination prepended operators last_login_at&#x3D;&lt;val&gt;, lat_login_at&#x3D;&lt;ne:val&gt;, last_login_at&#x3D;&lt;gt:val&gt;, last_login_at&#x3D;&lt;lt:val&gt; -- valid timestamp in the format: 2006-01-02T15:04:05.000000Z required
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public listPaginatedUsers(appId: string, page?: number, limit?: number, createdBefore?: number, orderBy?: string, identifier?: string, id?: string, loginCount?: number, status?: string, emailVerified?: boolean, createdAt?: string, updatedAt?: string, lastLoginAt?: string, options?: any) {
        return UsersApiFp(this.configuration).listPaginatedUsers(appId, page, limit, createdBefore, orderBy, identifier, id, loginCount, status, emailVerified, createdAt, updatedAt, lastLoginAt, options)(this.fetch, this.basePath);
    }

    /**
     * Update a user's information.
     * @summary Update User
     * @param {UpdateUserRequest} body user settings
     * @param {string} appId App ID
     * @param {string} userId user ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(body: UpdateUserRequest, appId: string, userId: string, options?: any) {
        return UsersApiFp(this.configuration).updateUser(body, appId, userId, options)(this.fetch, this.basePath);
    }

}
